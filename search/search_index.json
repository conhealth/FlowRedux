{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlowRedux \u00b6 Building async. running Kotlin Multiplatform state machine made easy with a DSL and coroutines. Usage \u00b6 Full documentation and best practices can be found here: https://freeletics.github.io/FlowRedux/ sealed class State object LoadingState : State () data class ContentState ( val items : List < Item > ) : State () data class ErrorState ( val error : Throwable ) : State () sealed class Action object RetryLoadingAction : Action () class MyStateMachine : FlowReduxStateMachine < State , Action > ( LoadingState ){ init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // executes this block whenever we enter LoadingState try { val items = loadItems () // suspending function / coroutine to load items OverrideState ( ContentState ( items ) ) // Transition to ContentState } catch ( t : Throwable ) { OverrideState ( ErrorState ( t ) ) // Transition to ErrorState } } } inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> // executes this block whenever ErrorState is current state and RetryLoadingAction is emitted OverrideState ( LoadingState ) // Transition to LoadingState which loads list again } } inState < ContentState > { collectWhileInState ( flowOf ( 1 , 2 , 3 ) ) { value : Int , stateSnapshot : ContentState -> // observes the given flow as long as state is ContentState. // Once state is changed to another state the flow will automatically // stop emitting. MutateState < ContentState , State > { copy ( items = this . items + Item ( \"New item $ value \" )) } } } } } } val statemachine = MyStateMachine () launch { // Launch a coroutine statemachine . state . collect { state -> // do something with new state like update UI renderUI ( state ) } } // emit an Action launch { // Launch a coroutine statemachine . dispatch ( Action ) } In an Android Application you could use it with AndroidX ViewModel like that: class MyViewModel @Inject constructor ( private val stateMachine : StateMachine ) : ViewModel () { val state = MutableLiveData < State > () init { viewModelScope . launch { // automatically canceled once ViewModel lifecycle reached destroyed. stateMachine . state . collect { newState -> state . value = newState } } } fun dispatch ( action : Action ) { viewModelScope . launch { stateMachine . dispatch ( action ) } } } Dependencies \u00b6 There are two artifacts that you can include as dependency:: 1. flowredux : this is the core library. Usually you dont want to use the core library directly but rather use the dsl . 2. dsl which provides a convenient DSL on top of the core library. Usually this is what you want. Multiplatform \u00b6 implementation 'com.freeletics.flowredux:flowredux:0.7.0' implementation 'com.freeletics.flowredux:dsl:0.7.0' JVM only \u00b6 implementation 'com.freeletics.flowredux:flowredux-jvm:0.7.0' implementation 'com.freeletics.flowredux:dsl-jvm:0.7.0' Native binaries \u00b6 implementation 'com.freeletics.flowredux:flowredux-iosx64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-iosarm64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-iosarm32:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosx86:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm32:0.7.0' implementation 'com.freeletics.flowredux:flowredux-tvosx64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-tvosxarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosx64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosarm32:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosx86:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosarm32:0.7.0' implementation 'com.freeletics.flowredux:dsl-tvosx64:0.7.0' implementation 'com.freeletics.flowredux:dsl-tvosxarm64:0.7.0' JavaScript \u00b6 No javascript version release yet but its on our TODO list. Snapshot \u00b6 Latest snapshot (directly published from master branch from Travis CI): allprojects { repositories { // Your repositories. // ... // Add url to snapshot repository maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } } Then just use -SNAPSHOT suffix as version like implementation 'com.freeletics.flowredux:dsl:0.7.1-SNAPSHOT'","title":"FlowRedux"},{"location":"#flowredux","text":"Building async. running Kotlin Multiplatform state machine made easy with a DSL and coroutines.","title":"FlowRedux"},{"location":"#usage","text":"Full documentation and best practices can be found here: https://freeletics.github.io/FlowRedux/ sealed class State object LoadingState : State () data class ContentState ( val items : List < Item > ) : State () data class ErrorState ( val error : Throwable ) : State () sealed class Action object RetryLoadingAction : Action () class MyStateMachine : FlowReduxStateMachine < State , Action > ( LoadingState ){ init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // executes this block whenever we enter LoadingState try { val items = loadItems () // suspending function / coroutine to load items OverrideState ( ContentState ( items ) ) // Transition to ContentState } catch ( t : Throwable ) { OverrideState ( ErrorState ( t ) ) // Transition to ErrorState } } } inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> // executes this block whenever ErrorState is current state and RetryLoadingAction is emitted OverrideState ( LoadingState ) // Transition to LoadingState which loads list again } } inState < ContentState > { collectWhileInState ( flowOf ( 1 , 2 , 3 ) ) { value : Int , stateSnapshot : ContentState -> // observes the given flow as long as state is ContentState. // Once state is changed to another state the flow will automatically // stop emitting. MutateState < ContentState , State > { copy ( items = this . items + Item ( \"New item $ value \" )) } } } } } } val statemachine = MyStateMachine () launch { // Launch a coroutine statemachine . state . collect { state -> // do something with new state like update UI renderUI ( state ) } } // emit an Action launch { // Launch a coroutine statemachine . dispatch ( Action ) } In an Android Application you could use it with AndroidX ViewModel like that: class MyViewModel @Inject constructor ( private val stateMachine : StateMachine ) : ViewModel () { val state = MutableLiveData < State > () init { viewModelScope . launch { // automatically canceled once ViewModel lifecycle reached destroyed. stateMachine . state . collect { newState -> state . value = newState } } } fun dispatch ( action : Action ) { viewModelScope . launch { stateMachine . dispatch ( action ) } } }","title":"Usage"},{"location":"#dependencies","text":"There are two artifacts that you can include as dependency:: 1. flowredux : this is the core library. Usually you dont want to use the core library directly but rather use the dsl . 2. dsl which provides a convenient DSL on top of the core library. Usually this is what you want.","title":"Dependencies"},{"location":"#multiplatform","text":"implementation 'com.freeletics.flowredux:flowredux:0.7.0' implementation 'com.freeletics.flowredux:dsl:0.7.0'","title":"Multiplatform"},{"location":"#jvm-only","text":"implementation 'com.freeletics.flowredux:flowredux-jvm:0.7.0' implementation 'com.freeletics.flowredux:dsl-jvm:0.7.0'","title":"JVM only"},{"location":"#native-binaries","text":"implementation 'com.freeletics.flowredux:flowredux-iosx64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-iosarm64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-iosarm32:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosx86:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm32:0.7.0' implementation 'com.freeletics.flowredux:flowredux-tvosx64:0.7.0' implementation 'com.freeletics.flowredux:flowredux-tvosxarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosx64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-iosarm32:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosx86:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosarm64:0.7.0' implementation 'com.freeletics.flowredux:dsl-watchosarm32:0.7.0' implementation 'com.freeletics.flowredux:dsl-tvosx64:0.7.0' implementation 'com.freeletics.flowredux:dsl-tvosxarm64:0.7.0'","title":"Native binaries"},{"location":"#javascript","text":"No javascript version release yet but its on our TODO list.","title":"JavaScript"},{"location":"#snapshot","text":"Latest snapshot (directly published from master branch from Travis CI): allprojects { repositories { // Your repositories. // ... // Add url to snapshot repository maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } } Then just use -SNAPSHOT suffix as version like implementation 'com.freeletics.flowredux:dsl:0.7.1-SNAPSHOT'","title":"Snapshot"},{"location":"contributing/","text":"Contributing \u00b6 To be done.","title":"Contributing"},{"location":"contributing/#contributing","text":"To be done.","title":"Contributing"},{"location":"dsl/","text":"DSL Guide \u00b6 FlowRedux provides a convenient DSL to describe your state machine. This page introduces you the DSL that you can use. To do that we will stick with a simple example of loading a list of items from a web service. As you read this section and more concepts of the DSL will be introduced we will extend this sample. For now to get started, let\u2019s define the States our state machine has. As said before we load a list of items from a web service and display that list. While loading the list we show a loading indicator on the screen and if an error occurs we show an error message on the screen with a retry button. This gives us the following states: sealed class State { // Shows a loading indicator on screen object LoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item > ) : State () // Error while loading happened data class ErrorState ( val cause : Throwable ) : State () } If we reached ErrorState we display an error message but also a button a user can click to retry loading the items. This gives us the following Actions : sealed class Action { object RetryLoadingAction : Action () } Initial State \u00b6 Every FlowReduxStateMachine needs an initial state. This is in which state the state machine starts. In our example we start with the LoadingState . class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { // will be filled in next section ... } } } Please note the constructor parameter of FlowReduxStateMachine(initialState = ...) . This is how you define the initial state of your state machine. Next, we already see that we need an init {...} block containing a spec { ... } block inside. The spec { ... } block is actually where we write our DSL inside. ChangeState \u00b6 One key concept of the FlowRedux DSL is that the return type of every function such as onEnter , onAction and collectWhileInState (we will learn about them later) is of type ChangeState<State> . For example: suspend fun handleLoadingAction ( stateSnapshot : State ): ChangeState < State > { val items = loadItems () // suspend function return OverrideState ( ShowContentState ( items )) // OverrideState extends from ChangeState. We will talk about it in 1 minutes. } As the name suggests ChangeState<State> is the way to tell the Redux store what the next state is or how to \u201ccompute\u201d the next state(often also called reduce state). ChangeState is a sealed class. You never use ChangeState directly but only one of the subtypes. There are 3 subtypes that cover different use cases: OverrideState<S>(nextState : State) MutateState<SubState, State>( reducer: (currentState : SubState) -> State ) NoStateChange Next, let\u2019s talk about these 3 types of ChangeState in detail. OverrideState<S>(nextState : State) \u00b6 OverrideState<S>(nextState : State) is overriding the current state of your redux store to whatever you pass in as parameter. By using OverrideState you basically say \u201cI don\u2019t care what the current state is, just set state to whatever I give you\u201d. This is used if computing the next state is independent of current state. You literally override the state regardless of what the current state is. Usage: suspend fun handleFooAction ( action : Action , stateSnapshot : State ): ChangeState < State > { ... return OverrideState ( SomeOtherState ()) } MutateState<SubState, State>( reducer: (currentState : SubState) -> State ) \u00b6 MutateState<SubState, State>( reducer: (currentState : SubState) -> State ) is used if your next state computation is based on the current state. Thus, MutateState expects a lambda block with signature (State) -> State . This is a so-called reducer function to compute the next state. You may wonder why MutateState takes such a lambda as constructor parameter and not a new state instance as OverrideState does? The reason is that FlowRedux is an asynchronous state machine meaning multiple coroutines can run in parallel and mutate state. Here is a very simple example (we will discuss the exact details of the used DSL later in this documentat): suspend fun createRandomItem (): Item { val random = ( 0. . 10 ). random () delay ( random * 1000 ) // randomly wait for up to 10 seconds return Item ( \"random $ random \" ) } ... // DSL specs spec { inState < ShowContent > { on < AddItemAction > { action : AddItemAction , state : ShowContent -> val item : Item = createRandomItem () MutateState { currentState : ShowContent -> currentState . copy ( items = currentState . items + item ) } } } } As you see createRandomItem() can take some time to return a value. Furthermore, every invocation of createRandomItem() could take differently long to return a value. Let\u2019s take a look at the following scenario: current state of our FlowRedux state machine is ShowContent(items = listof( Item(\"1\"), Item(\"2\"))) . Next we trigger AddItemAction 2 times very fast (within a few milliseconds) one after each other which eventually triggers createRandomItem() 2 times. Let\u2019s assume the first invocation of createRandomItem() takes 6 seconds to return new item, the second invocation takes 3 seconds. What is the expected state after this two AddItemAction are handled? There should be 2 state changes: First ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"))) and secondly ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"), Item(\"random 6\"))) . This is exactly what we get by using MutateState . If we use OverrideState or MutateState would not have a reducer lambda as parameter then the code as follows: // DSL specs spec { inState < ShowContent > { on < AddItemAction > { action : AddItemAction , state : ShowContent -> val item : Item = createRandomItem () // WRONG: don't do that. This is just to demo an issue (see explanation bellow). OverrideState ( state . copy ( items = currentState . items + item )) // or MutateState( state.copy(items = currentState.items + item) ) } } } and state transition are as follows: First ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"))) and secondly ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 6\"))) . How comes that the second state transition produces ShowContent without Item(\"random 3\") ? The reson is that we are accessing the state parameter on<AddItemAction> { action: AddItemAction, state: ShowContent -> ... } and that this state parameter is actually only a snapshot of the state when on<AddItemAction> did trigger. In our example this is always capturing the following state ShowContent(items = listof( Item(\"1\"), Item(\"2\") ) ) The state could have changed before reaching return OverrideState(...) . Well, that is exactly what is happening. Remember, within a few milliseconds we dispatch 2 times AddItemAction and then it takes 3 and 6 seconds for createRandomItem() to return. Thus, the state transition actually overrides the first state transition. This is why you must use MutateState with a reducer lambda in such cases when you want to change some properties of the current state (but not transition to an entirely different state like ErrorState ) to handle cases properly where parallel execution could have changed the state in the meantime. NoStateChange \u00b6 NoStateChange is the last option that you have for ChangeState and it should be only used very carefully to cover some cases that could not be covered otherwise. NoStateChange is an object , thus a singleton. Basically what NoStateChange is good for is to tell that you actually dont want to do a state transition. When you need this? Again, there should be only very limited use case for NoStateChange but most likely if there is really no other way then at runtime check for some conditions and then either trigger OverrideState , MutateState or NoChangeState if state should really not change (but you really only know that at runtime only, but this is usually an indicator that you should rethink your state modelling to avoid having this issue). Usage: suspend fun handleFooAction ( action : Action , stateSnapshot : State ) { if ( action . data == \"foo\" && stateSnapshot . data == \"bar\" ) // just demo some random condition check return NoStateChange ... return OverrideState ( OtherState ()) } inState <State> \u00b6 The first concept we learn is inState class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { ... } } } } Please note that inState itself doesn\u2019t do anything. All we did so far with inState<LoadingState> is set an entry point. Next let\u2019s discuss what an inState can contain as triggers to actually \u201cdo something\u201d: onEnter : Triggers whenever we enter that state on<Action> : Triggers whenever we are in this state and the specified action is triggered from the outside by calling FlowReduxStateMachine.dispatch(action) . collectWhileInState( flow ) : You can subscribe to any arbitrary Flow while your state machine is in that state. Let\u2019s go through them as we build our state machine. onEnter \u00b6 What do we want to do when we enter the LoadingState ? We want to do the http request, right? Let\u2019s do that by extending our example: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () // loadItems() is a suspend function OverrideState ( ShowContentState ( items )) // return OverrideState } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } } } } There are a some new things like onEnter and OverrideState . We covered OverrideState in a dedicated section . Let\u2019s talk about onEnter : onEnter { ... } is running asynchronously in a coroutine . That means whatever you do inside the onEnter block is not blocking anything else. You can totally run here long-running and expensive calls (like doing a http request). onEnter { ... } expects a lambda (or function) with the following signature: onEnter( (State) -> ChangeState<State> ) : OverrideState extends from ChangeState . The execution of the onEnter { ... } is canceled as soon as state condition specified in the surrounding inState doesn\u2019t hold anymore (i.e. state has been changes by something else). on <Action> \u00b6 How do we deal with external user input like clicks in FlowRedux? This is what Actions are for. In FlowRedux DSL you can react on Actions by using a on<MyAction>{ ... } block. In our example we want to retry loading if we are in ErrorState and the user clicks on a retry button. Clicking on that button dispatches a RetryLoadingAction to our state machine. Let\u2019s extend our FlowReduxStateMachine to react on such an action if the current state is ErrorState : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } // let's add a new inState{...} with an on{...} block inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> // This block triggers if we are in ErrorState // RetryLoadingAction has been dispatched to this state machine. // In that case we transition to LoadingState which then starts the http // request to load items again as the inState<LoadingState> + onEnter { ... } triggers OverrideState ( LoadingState ) } } } } } A on { ... } block gets 3 parameters: action which is the actual instance of the Action that triggered this block and stateSnapshot which is a snapshot of the current state. on { ... } is actually pretty similar to onEnter {...} just with a different \u201ctrigger\u201d (action vs. entering a state) . Furthermore, on { ... } has the same characteristics as onEnter { ... } : on { ... } is running asynchronously in a coroutine . That means whatever you do inside the on block is not blocking anything else. You can totally run here long-running and expensive calls (like doing a http request). on { ... } expects a lambda (or function) with the following signature: (action : Action , stateSnapshot : State) -> ChangeState<State> . The execution of the on { ... } is canceled as soon as state condition specified in the surrounding inState doesn\u2019t hold anymore (i.e. state has been changes by something else). collectWhileInState() \u00b6 This one is useful if you want to collect a Flow only while being exactly in that state. To give a concrete example how this is useful let\u2019s extend our example from above. Let\u2019s say whenever our state machine is in ErrorState we want to retry loading the items after 3 seconds in ErrorState or anytime before the 3 seconds have elapsed if the user clicks the retry button. Furthermore the 3 seconds countdown timer should be displayed in our app: To implement this let\u2019s first extend our ErrorState : data class ErrorState ( val cause : Throwable , val countdown : Int // This value is decreased from 3 then 2 then 1 and represents the countdown value. ) : State () Now let\u2019s add some countdown capabilities to our state machine by using collectWhileInState() : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } // let's add a new inState{...} with an on{...} block inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value : Int , stateSnapshot : ErrorState -> // This block triggers every time the timer emits // which happens every second MutateState < ErrorState , State > { // in this block, this references ErrorState if ( countdown > 0 ) // is the same as this.countdown references ErrorState copy ( countdown = countdown - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } } } } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Let\u2019s look at the source code above step by step. Whenever we are in LoadingState and an error occurs while loading the items we go into ErrorState . Nothing has changes from previous code snipped. What is new is that ErrorState contains an additional field countdown which we set on transitioning from LoadingState to ErrorState(countdown = 3) (means 3 seconds left). We extend inState<ErrorState> { ... } block and add a collectWhileInState(timer) . timer is a Flow<Int> that emits a new (incremented) number every second. collectWhileInState(timer) calls .collect {...} on the flow passed as parameter and executes the block with the parameters value every time timer emits a new value. In other words: instead of calling timer.collect { ... } you call collectWhileInState(timer) { ... } to collect the Flow\u2019s values as long as the state machine is in that state. The passed Flow (in our case the timer) is automatically canceled once the state machine transitioned from ErrorState into another state. This happens either when the user clicks on the retry button and which triggers on<RetryLoadingAction> which causes a state transition to LoadingState or when 3 seconds have elapsed because then the defined MutateState causes a transitions to LoadingState . Custom condition for inState \u00b6 We already covered inState<State> that builds upon the recommended best practice that every State in your state machine is expressed us it\u2019s own type in Kotlin. Again, this is a best practice and the recommended way. Sometimes, however, you need a bit more flexibility then just relaying on type. For that use case you can use inStateWithCondition(isInState: (State) -> Boolean) . Example: One could have also modeled the state for our example above as the following: // TO MODEL YOUR STATE LIKE THIS IS NOT BEST PRACTICE! Use sealed class instead. data class State ( val loading : Boolean , // true means loading, false means not loading val items : List < Items > , // empty list if no items loaded yet val error : Throwable?, // if not null we are in error state val errorCountDown : Int? // the seconds for the error countdown ) AGAIN, the example shown above is not the recommended way. We strongly recommend to use sealed classes instead to model state as shown at the beginning of this document. We just do this for demo purpose to demonstrate a way how to customize inState . Given the state from above, what we can do now with our DSL is the following: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = State ( loading = true , items = emptyList (), error = null , errorCountDown = null ) ) { init { spec { inStateWithCondition ( isInState = { state -> state . loading == true }) { onEnter { stateSnapshot : State -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( State ( loading = false , items = items , error = null , errorCountdown = null ) ) } catch ( t : Throwable ) { OverrideState ( State ( loading = false , items = emptyList (), error = t , errorCountdown = 3 ) ) // Countdown starts with 3 seconds } } } inStateWithCondition ( isInState = { state -> state . error != null }) { on < RetryLoadingAction > { action , stateSnapshot -> OverrideState ( State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value , stateSnapshot -> MutateState < State , State > { if ( errorCountdown !! > 0 ) copy ( errorCountdown = errorCountdown !! - 1 ) // decrease the countdown by 1 second else State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) // transition to the LoadingState } } } } } } Instead of inState<State> { ... } we can use inStateWithCondition that instead of generics take a lambda as parameter that looks like (State) -> Boolean so that. If that lambda returns true it means we are in that state, otherwise not (returning false). The rest still remains the same. You can use onEnter , on<Action> and collectWhileInState the exact way as you already know. However, since inStateWithCondition has no generics, FlowRedux cannot infer types in onEnter , on , etc. Acting across multiple states \u00b6 If for whatever reason you want to trigger a state change for all states you can achieve that by using inState<> on a base class. // DSL specs spec { inState < State > { // on, onEnter, collectWhileInState for all states // because State is the base class these would never get cancelled } inState < Loading > { // on, onEnter, collectWhileInState specific to Loading } inState < ShowContent > { // on, onEnter, collectWhileInState specific to ShowContent } } In case you want to trigger state changes from a subset of states you could introduce another level to your state class hierarchy. For example the following would allow you to have a inState<PostLoadingState> block to share actions between ShowContentState and ErrorState : sealed class State { // Shows a loading indicator on screen object LoadingState : State () sealed class PostLoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item > ) : PostLoadingState () // Error while loading happened data class ErrorState ( val cause : Throwable ) : PostLoadingState () } FlatMapPolicy \u00b6 Have you ever wondered what would happen if you would execute Action very fast 1 after another? For example: spec { inState < FooState > { on < BarAction > { action , stateSnapshot -> delay ( 5000 ) // wait for 5 seconds OverrideState ( OtherState ()) } } } The example above shows a problem with async. state machines like FlowRedux: If our state machine is in FooState and a BarAction got triggered, we wait for 5 seconds and then set the state to another state. What if while waiting 5 seconds (i.e. let\u2019s say after 3 seconds of waiting) another BarAction gets triggered. That is possible right? With FlatMapPolicy you can specify what should happen in that case. There are three options to choose from: LATEST : This is the default one. It would cancel any previous execution and just run the latest one. In the example above it would meanwhile wait 5 seconds another BarAction gets triggered, the first execution of on<BarAction> block gets stopped and a new on<BarAction> block starts. MERGE : Choosing this causes all the blocks to continue running but there are no guarantees in which order. For example: spec { inState < FooState > { on < BarAction > ( flatMapPolicy = FlapMapPolicy . MERGE ) { _ , _ , setState -> delay ( randomInt ()) // wait for some random time setState { OtherState } } } } Let\u2019s assume that we trigger two times BarAction . We use random amount of seconds for waiting. Since we use MERGE on<BarAction> block gets executed 2 times without canceling the previous one (that is the difference to LATEST ). Moreover, MERGE doesn\u2019t make any promise on order of execution of the block (see CONCAT if you need promises on order). So if on<BarAction> gets executed two times it will run in parallel and the the second execution could complete before the first execution (because using a random time of waiting). CONCAT : In contrast to MERGE and LATEST CONCAT will not run on<BarAction> in parallel and will not cancel any previous execution. Instead, CONCAT will preserve the order and execute one block after another. All execution blocks except onEnter can specify a FlatMapPolicy : on<Action>(flatMapPolicy = FlatMapPolicy.LATEST){... } collectWhileInState(flatMapPolicy = FlatMapPolicy.LATEST) { ... } Best Practice \u00b6 One very important aspect of the DSL is to provide a readable and maintainable way to reason about your state machine. Let\u2019 take a look at our example state machine: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( cause = t , countdown = 3 )) // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , stateSnapshot -> OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value , stateSnapshot -> MutateState < ErrorState , State > { if ( this . countdownTimeLeft > 0 ) // this is referencing ErrorState this . copy ( countdown = countdownTimeLeft - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Do you notice something? With more blocks we add the state machine itself gets harder to read, understand and maintain. What we are aiming for with the DSL is an overview about what the state machine is supposed to do on a high level that reads like as specification. If you take a look at the example from above, however, you will notice that it isn\u2019t easy to read and get bloated with implementation details. The recommended way \u00b6 We recommend keeping the DSL really short, expressive, readable and maintainable. Therefore instead of having implementation details in your DSL we recommend to use function references instead. Let\u2019s refactor the example above to reflect this idea: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { // // This is the specification of your state machine. Less implementation details, better readability. // init { spec { inState < LoadingState > { onEnter ( :: loadItemsAndMoveToContentOrErrorState ) } inState < ErrorState > { on < RetryLoadingAction > { action , stateSnapshot -> // For a single line statement it's ok to keep the block instead of moving to a function reference OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond (), :: onSecondElapsedMoveToLoadingStateOrDecrementCountdown ) } } } // // All the implementation details are in the functions below. // private fun loadItemsAndMoveToContentOrErrorState ( stateSnapshot : LoadingState ): ChangeState < State > { return try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( cause = t , countdown = 3 )) // Countdown starts with 3 seconds } } private fun onSecondElapsedMoveToLoadingStateOrDecrementCountdown ( value : Int , stateSnapshot : ErrorState ): ChangeState < State > { return MutateState < ErrorState , State > { if ( this . countdownTimeLeft > 0 ) // this is referencing ErrorState this . copy ( countdown = countdownTimeLeft - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } By using function references you can read the DSL better and can zoom in into implementation details anytime you want to by looking into a function body.","title":"DSL Guide"},{"location":"dsl/#dsl-guide","text":"FlowRedux provides a convenient DSL to describe your state machine. This page introduces you the DSL that you can use. To do that we will stick with a simple example of loading a list of items from a web service. As you read this section and more concepts of the DSL will be introduced we will extend this sample. For now to get started, let\u2019s define the States our state machine has. As said before we load a list of items from a web service and display that list. While loading the list we show a loading indicator on the screen and if an error occurs we show an error message on the screen with a retry button. This gives us the following states: sealed class State { // Shows a loading indicator on screen object LoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item > ) : State () // Error while loading happened data class ErrorState ( val cause : Throwable ) : State () } If we reached ErrorState we display an error message but also a button a user can click to retry loading the items. This gives us the following Actions : sealed class Action { object RetryLoadingAction : Action () }","title":"DSL Guide"},{"location":"dsl/#initial-state","text":"Every FlowReduxStateMachine needs an initial state. This is in which state the state machine starts. In our example we start with the LoadingState . class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { // will be filled in next section ... } } } Please note the constructor parameter of FlowReduxStateMachine(initialState = ...) . This is how you define the initial state of your state machine. Next, we already see that we need an init {...} block containing a spec { ... } block inside. The spec { ... } block is actually where we write our DSL inside.","title":"Initial State"},{"location":"dsl/#changestate","text":"One key concept of the FlowRedux DSL is that the return type of every function such as onEnter , onAction and collectWhileInState (we will learn about them later) is of type ChangeState<State> . For example: suspend fun handleLoadingAction ( stateSnapshot : State ): ChangeState < State > { val items = loadItems () // suspend function return OverrideState ( ShowContentState ( items )) // OverrideState extends from ChangeState. We will talk about it in 1 minutes. } As the name suggests ChangeState<State> is the way to tell the Redux store what the next state is or how to \u201ccompute\u201d the next state(often also called reduce state). ChangeState is a sealed class. You never use ChangeState directly but only one of the subtypes. There are 3 subtypes that cover different use cases: OverrideState<S>(nextState : State) MutateState<SubState, State>( reducer: (currentState : SubState) -> State ) NoStateChange Next, let\u2019s talk about these 3 types of ChangeState in detail.","title":"ChangeState"},{"location":"dsl/#overridestatesnextstate-state","text":"OverrideState<S>(nextState : State) is overriding the current state of your redux store to whatever you pass in as parameter. By using OverrideState you basically say \u201cI don\u2019t care what the current state is, just set state to whatever I give you\u201d. This is used if computing the next state is independent of current state. You literally override the state regardless of what the current state is. Usage: suspend fun handleFooAction ( action : Action , stateSnapshot : State ): ChangeState < State > { ... return OverrideState ( SomeOtherState ()) }","title":"OverrideState&lt;S&gt;(nextState : State)"},{"location":"dsl/#mutatestatesubstate-state-reducer-currentstate-substate-state","text":"MutateState<SubState, State>( reducer: (currentState : SubState) -> State ) is used if your next state computation is based on the current state. Thus, MutateState expects a lambda block with signature (State) -> State . This is a so-called reducer function to compute the next state. You may wonder why MutateState takes such a lambda as constructor parameter and not a new state instance as OverrideState does? The reason is that FlowRedux is an asynchronous state machine meaning multiple coroutines can run in parallel and mutate state. Here is a very simple example (we will discuss the exact details of the used DSL later in this documentat): suspend fun createRandomItem (): Item { val random = ( 0. . 10 ). random () delay ( random * 1000 ) // randomly wait for up to 10 seconds return Item ( \"random $ random \" ) } ... // DSL specs spec { inState < ShowContent > { on < AddItemAction > { action : AddItemAction , state : ShowContent -> val item : Item = createRandomItem () MutateState { currentState : ShowContent -> currentState . copy ( items = currentState . items + item ) } } } } As you see createRandomItem() can take some time to return a value. Furthermore, every invocation of createRandomItem() could take differently long to return a value. Let\u2019s take a look at the following scenario: current state of our FlowRedux state machine is ShowContent(items = listof( Item(\"1\"), Item(\"2\"))) . Next we trigger AddItemAction 2 times very fast (within a few milliseconds) one after each other which eventually triggers createRandomItem() 2 times. Let\u2019s assume the first invocation of createRandomItem() takes 6 seconds to return new item, the second invocation takes 3 seconds. What is the expected state after this two AddItemAction are handled? There should be 2 state changes: First ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"))) and secondly ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"), Item(\"random 6\"))) . This is exactly what we get by using MutateState . If we use OverrideState or MutateState would not have a reducer lambda as parameter then the code as follows: // DSL specs spec { inState < ShowContent > { on < AddItemAction > { action : AddItemAction , state : ShowContent -> val item : Item = createRandomItem () // WRONG: don't do that. This is just to demo an issue (see explanation bellow). OverrideState ( state . copy ( items = currentState . items + item )) // or MutateState( state.copy(items = currentState.items + item) ) } } } and state transition are as follows: First ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 3\"))) and secondly ShowContent(items = listof( Item(\"1\"), Item(\"2\"), Item(\"random 6\"))) . How comes that the second state transition produces ShowContent without Item(\"random 3\") ? The reson is that we are accessing the state parameter on<AddItemAction> { action: AddItemAction, state: ShowContent -> ... } and that this state parameter is actually only a snapshot of the state when on<AddItemAction> did trigger. In our example this is always capturing the following state ShowContent(items = listof( Item(\"1\"), Item(\"2\") ) ) The state could have changed before reaching return OverrideState(...) . Well, that is exactly what is happening. Remember, within a few milliseconds we dispatch 2 times AddItemAction and then it takes 3 and 6 seconds for createRandomItem() to return. Thus, the state transition actually overrides the first state transition. This is why you must use MutateState with a reducer lambda in such cases when you want to change some properties of the current state (but not transition to an entirely different state like ErrorState ) to handle cases properly where parallel execution could have changed the state in the meantime.","title":"MutateState&lt;SubState, State&gt;( reducer: (currentState : SubState) -&gt; State )"},{"location":"dsl/#nostatechange","text":"NoStateChange is the last option that you have for ChangeState and it should be only used very carefully to cover some cases that could not be covered otherwise. NoStateChange is an object , thus a singleton. Basically what NoStateChange is good for is to tell that you actually dont want to do a state transition. When you need this? Again, there should be only very limited use case for NoStateChange but most likely if there is really no other way then at runtime check for some conditions and then either trigger OverrideState , MutateState or NoChangeState if state should really not change (but you really only know that at runtime only, but this is usually an indicator that you should rethink your state modelling to avoid having this issue). Usage: suspend fun handleFooAction ( action : Action , stateSnapshot : State ) { if ( action . data == \"foo\" && stateSnapshot . data == \"bar\" ) // just demo some random condition check return NoStateChange ... return OverrideState ( OtherState ()) }","title":"NoStateChange"},{"location":"dsl/#instatestate","text":"The first concept we learn is inState class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { ... } } } } Please note that inState itself doesn\u2019t do anything. All we did so far with inState<LoadingState> is set an entry point. Next let\u2019s discuss what an inState can contain as triggers to actually \u201cdo something\u201d: onEnter : Triggers whenever we enter that state on<Action> : Triggers whenever we are in this state and the specified action is triggered from the outside by calling FlowReduxStateMachine.dispatch(action) . collectWhileInState( flow ) : You can subscribe to any arbitrary Flow while your state machine is in that state. Let\u2019s go through them as we build our state machine.","title":"inState&lt;State&gt;"},{"location":"dsl/#onenter","text":"What do we want to do when we enter the LoadingState ? We want to do the http request, right? Let\u2019s do that by extending our example: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () // loadItems() is a suspend function OverrideState ( ShowContentState ( items )) // return OverrideState } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } } } } There are a some new things like onEnter and OverrideState . We covered OverrideState in a dedicated section . Let\u2019s talk about onEnter : onEnter { ... } is running asynchronously in a coroutine . That means whatever you do inside the onEnter block is not blocking anything else. You can totally run here long-running and expensive calls (like doing a http request). onEnter { ... } expects a lambda (or function) with the following signature: onEnter( (State) -> ChangeState<State> ) : OverrideState extends from ChangeState . The execution of the onEnter { ... } is canceled as soon as state condition specified in the surrounding inState doesn\u2019t hold anymore (i.e. state has been changes by something else).","title":"onEnter"},{"location":"dsl/#onaction","text":"How do we deal with external user input like clicks in FlowRedux? This is what Actions are for. In FlowRedux DSL you can react on Actions by using a on<MyAction>{ ... } block. In our example we want to retry loading if we are in ErrorState and the user clicks on a retry button. Clicking on that button dispatches a RetryLoadingAction to our state machine. Let\u2019s extend our FlowReduxStateMachine to react on such an action if the current state is ErrorState : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } // let's add a new inState{...} with an on{...} block inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> // This block triggers if we are in ErrorState // RetryLoadingAction has been dispatched to this state machine. // In that case we transition to LoadingState which then starts the http // request to load items again as the inState<LoadingState> + onEnter { ... } triggers OverrideState ( LoadingState ) } } } } } A on { ... } block gets 3 parameters: action which is the actual instance of the Action that triggered this block and stateSnapshot which is a snapshot of the current state. on { ... } is actually pretty similar to onEnter {...} just with a different \u201ctrigger\u201d (action vs. entering a state) . Furthermore, on { ... } has the same characteristics as onEnter { ... } : on { ... } is running asynchronously in a coroutine . That means whatever you do inside the on block is not blocking anything else. You can totally run here long-running and expensive calls (like doing a http request). on { ... } expects a lambda (or function) with the following signature: (action : Action , stateSnapshot : State) -> ChangeState<State> . The execution of the on { ... } is canceled as soon as state condition specified in the surrounding inState doesn\u2019t hold anymore (i.e. state has been changes by something else).","title":"on&lt;Action&gt;"},{"location":"dsl/#collectwhileinstate","text":"This one is useful if you want to collect a Flow only while being exactly in that state. To give a concrete example how this is useful let\u2019s extend our example from above. Let\u2019s say whenever our state machine is in ErrorState we want to retry loading the items after 3 seconds in ErrorState or anytime before the 3 seconds have elapsed if the user clicks the retry button. Furthermore the 3 seconds countdown timer should be displayed in our app: To implement this let\u2019s first extend our ErrorState : data class ErrorState ( val cause : Throwable , val countdown : Int // This value is decreased from 3 then 2 then 1 and represents the countdown value. ) : State () Now let\u2019s add some countdown capabilities to our state machine by using collectWhileInState() : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { inState < LoadingState > { onEnter { stateSnapshot : LoadingState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( t )) } } } // let's add a new inState{...} with an on{...} block inState < ErrorState > { on < RetryLoadingAction > { action : RetryLoadingAction , stateSnapshot : ErrorState -> OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value : Int , stateSnapshot : ErrorState -> // This block triggers every time the timer emits // which happens every second MutateState < ErrorState , State > { // in this block, this references ErrorState if ( countdown > 0 ) // is the same as this.countdown references ErrorState copy ( countdown = countdown - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } } } } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Let\u2019s look at the source code above step by step. Whenever we are in LoadingState and an error occurs while loading the items we go into ErrorState . Nothing has changes from previous code snipped. What is new is that ErrorState contains an additional field countdown which we set on transitioning from LoadingState to ErrorState(countdown = 3) (means 3 seconds left). We extend inState<ErrorState> { ... } block and add a collectWhileInState(timer) . timer is a Flow<Int> that emits a new (incremented) number every second. collectWhileInState(timer) calls .collect {...} on the flow passed as parameter and executes the block with the parameters value every time timer emits a new value. In other words: instead of calling timer.collect { ... } you call collectWhileInState(timer) { ... } to collect the Flow\u2019s values as long as the state machine is in that state. The passed Flow (in our case the timer) is automatically canceled once the state machine transitioned from ErrorState into another state. This happens either when the user clicks on the retry button and which triggers on<RetryLoadingAction> which causes a state transition to LoadingState or when 3 seconds have elapsed because then the defined MutateState causes a transitions to LoadingState .","title":"collectWhileInState()"},{"location":"dsl/#custom-condition-for-instate","text":"We already covered inState<State> that builds upon the recommended best practice that every State in your state machine is expressed us it\u2019s own type in Kotlin. Again, this is a best practice and the recommended way. Sometimes, however, you need a bit more flexibility then just relaying on type. For that use case you can use inStateWithCondition(isInState: (State) -> Boolean) . Example: One could have also modeled the state for our example above as the following: // TO MODEL YOUR STATE LIKE THIS IS NOT BEST PRACTICE! Use sealed class instead. data class State ( val loading : Boolean , // true means loading, false means not loading val items : List < Items > , // empty list if no items loaded yet val error : Throwable?, // if not null we are in error state val errorCountDown : Int? // the seconds for the error countdown ) AGAIN, the example shown above is not the recommended way. We strongly recommend to use sealed classes instead to model state as shown at the beginning of this document. We just do this for demo purpose to demonstrate a way how to customize inState . Given the state from above, what we can do now with our DSL is the following: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = State ( loading = true , items = emptyList (), error = null , errorCountDown = null ) ) { init { spec { inStateWithCondition ( isInState = { state -> state . loading == true }) { onEnter { stateSnapshot : State -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( State ( loading = false , items = items , error = null , errorCountdown = null ) ) } catch ( t : Throwable ) { OverrideState ( State ( loading = false , items = emptyList (), error = t , errorCountdown = 3 ) ) // Countdown starts with 3 seconds } } } inStateWithCondition ( isInState = { state -> state . error != null }) { on < RetryLoadingAction > { action , stateSnapshot -> OverrideState ( State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value , stateSnapshot -> MutateState < State , State > { if ( errorCountdown !! > 0 ) copy ( errorCountdown = errorCountdown !! - 1 ) // decrease the countdown by 1 second else State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) // transition to the LoadingState } } } } } } Instead of inState<State> { ... } we can use inStateWithCondition that instead of generics take a lambda as parameter that looks like (State) -> Boolean so that. If that lambda returns true it means we are in that state, otherwise not (returning false). The rest still remains the same. You can use onEnter , on<Action> and collectWhileInState the exact way as you already know. However, since inStateWithCondition has no generics, FlowRedux cannot infer types in onEnter , on , etc.","title":"Custom condition for inState"},{"location":"dsl/#acting-across-multiple-states","text":"If for whatever reason you want to trigger a state change for all states you can achieve that by using inState<> on a base class. // DSL specs spec { inState < State > { // on, onEnter, collectWhileInState for all states // because State is the base class these would never get cancelled } inState < Loading > { // on, onEnter, collectWhileInState specific to Loading } inState < ShowContent > { // on, onEnter, collectWhileInState specific to ShowContent } } In case you want to trigger state changes from a subset of states you could introduce another level to your state class hierarchy. For example the following would allow you to have a inState<PostLoadingState> block to share actions between ShowContentState and ErrorState : sealed class State { // Shows a loading indicator on screen object LoadingState : State () sealed class PostLoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item > ) : PostLoadingState () // Error while loading happened data class ErrorState ( val cause : Throwable ) : PostLoadingState () }","title":"Acting across multiple states"},{"location":"dsl/#flatmappolicy","text":"Have you ever wondered what would happen if you would execute Action very fast 1 after another? For example: spec { inState < FooState > { on < BarAction > { action , stateSnapshot -> delay ( 5000 ) // wait for 5 seconds OverrideState ( OtherState ()) } } } The example above shows a problem with async. state machines like FlowRedux: If our state machine is in FooState and a BarAction got triggered, we wait for 5 seconds and then set the state to another state. What if while waiting 5 seconds (i.e. let\u2019s say after 3 seconds of waiting) another BarAction gets triggered. That is possible right? With FlatMapPolicy you can specify what should happen in that case. There are three options to choose from: LATEST : This is the default one. It would cancel any previous execution and just run the latest one. In the example above it would meanwhile wait 5 seconds another BarAction gets triggered, the first execution of on<BarAction> block gets stopped and a new on<BarAction> block starts. MERGE : Choosing this causes all the blocks to continue running but there are no guarantees in which order. For example: spec { inState < FooState > { on < BarAction > ( flatMapPolicy = FlapMapPolicy . MERGE ) { _ , _ , setState -> delay ( randomInt ()) // wait for some random time setState { OtherState } } } } Let\u2019s assume that we trigger two times BarAction . We use random amount of seconds for waiting. Since we use MERGE on<BarAction> block gets executed 2 times without canceling the previous one (that is the difference to LATEST ). Moreover, MERGE doesn\u2019t make any promise on order of execution of the block (see CONCAT if you need promises on order). So if on<BarAction> gets executed two times it will run in parallel and the the second execution could complete before the first execution (because using a random time of waiting). CONCAT : In contrast to MERGE and LATEST CONCAT will not run on<BarAction> in parallel and will not cancel any previous execution. Instead, CONCAT will preserve the order and execute one block after another. All execution blocks except onEnter can specify a FlatMapPolicy : on<Action>(flatMapPolicy = FlatMapPolicy.LATEST){... } collectWhileInState(flatMapPolicy = FlatMapPolicy.LATEST) { ... }","title":"FlatMapPolicy"},{"location":"dsl/#best-practice","text":"One very important aspect of the DSL is to provide a readable and maintainable way to reason about your state machine. Let\u2019 take a look at our example state machine: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { stateSnapshot -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( cause = t , countdown = 3 )) // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , stateSnapshot -> OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond ()) { value , stateSnapshot -> MutateState < ErrorState , State > { if ( this . countdownTimeLeft > 0 ) // this is referencing ErrorState this . copy ( countdown = countdownTimeLeft - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Do you notice something? With more blocks we add the state machine itself gets harder to read, understand and maintain. What we are aiming for with the DSL is an overview about what the state machine is supposed to do on a high level that reads like as specification. If you take a look at the example from above, however, you will notice that it isn\u2019t easy to read and get bloated with implementation details.","title":"Best Practice"},{"location":"dsl/#the-recommended-way","text":"We recommend keeping the DSL really short, expressive, readable and maintainable. Therefore instead of having implementation details in your DSL we recommend to use function references instead. Let\u2019s refactor the example above to reflect this idea: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action > ( initialState = LoadingState ) { // // This is the specification of your state machine. Less implementation details, better readability. // init { spec { inState < LoadingState > { onEnter ( :: loadItemsAndMoveToContentOrErrorState ) } inState < ErrorState > { on < RetryLoadingAction > { action , stateSnapshot -> // For a single line statement it's ok to keep the block instead of moving to a function reference OverrideState ( LoadingState ) } collectWhileInState ( timerThatEmitsEverySecond (), :: onSecondElapsedMoveToLoadingStateOrDecrementCountdown ) } } } // // All the implementation details are in the functions below. // private fun loadItemsAndMoveToContentOrErrorState ( stateSnapshot : LoadingState ): ChangeState < State > { return try { val items = httpClient . loadItems () OverrideState ( ShowContentState ( items )) } catch ( t : Throwable ) { OverrideState ( ErrorState ( cause = t , countdown = 3 )) // Countdown starts with 3 seconds } } private fun onSecondElapsedMoveToLoadingStateOrDecrementCountdown ( value : Int , stateSnapshot : ErrorState ): ChangeState < State > { return MutateState < ErrorState , State > { if ( this . countdownTimeLeft > 0 ) // this is referencing ErrorState this . copy ( countdown = countdownTimeLeft - 1 ) // decrease the countdown by 1 second else LoadingState // transition to the LoadingState } } private fun timerThatEmitsEverySecond (): Flow < Int > = flow { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } By using function references you can read the DSL better and can zoom in into implementation details anytime you want to by looking into a function body.","title":"The recommended way"},{"location":"flow_vs_FlowReduxStateMachine/","text":"FlowReduxStateMachine vs .reduxStore() \u00b6 The DSL provided by FlowRedux can be use int two ways: Extending from FlowReduxStateMachine Use .reduxStore() which is a custom operator on Kotlin\u2019s Flow type. FlowReduxStateMachine \u00b6 This is probably the easiest way to get started writing a State Machine with FlowRedux DSL. class MyStateMachine : FlowReduxStateMachine < State , Action > ( InitialState ){ init { spec { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } } } See DSL section for more information how to use the DSL. The advantage of extending from FlowReduxStateMachine is that you get a ready a base template where you just have to fill in the DSL part inside the spec { ... } block. By extending from FlowReduxStateMachine your StateMachine inherits a dispatch(action : Action) method to dispatch Actions to your state machine and a val state: Flow<State> to observe your state machine\u2019s state. Whenever the state changes, the latest State will be emitted to this Flow . .reduxStore() \u00b6 If you want to work with Flow type directly FlowRedux provides you a custom operator called .reduxStore() . It is a custom operator like any other Flow operator like Flow.map { ... } . The idea is that the upstream Flow brings the actions to your FlowReduxStore like this: sealed class Action { object Action1 : MyAction () object Action2 : MyAction () } val actionFlow : Flow < Action > = flowOf { emit ( Action1 ) delay ( 2000 ) emit ( Action2 ) } val stateFlow : Flow < State > = actionFlow // actionFlow is the input actions to the state machine . reduxStore < Action , State > ( IntialState ) { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } stateFlow . collect { state -> updateUi ( state ) }","title":"FlowReduxStateMachine vs .reduxStore()"},{"location":"flow_vs_FlowReduxStateMachine/#flowreduxstatemachine-vs-reduxstore","text":"The DSL provided by FlowRedux can be use int two ways: Extending from FlowReduxStateMachine Use .reduxStore() which is a custom operator on Kotlin\u2019s Flow type.","title":"FlowReduxStateMachine vs .reduxStore()"},{"location":"flow_vs_FlowReduxStateMachine/#flowreduxstatemachine","text":"This is probably the easiest way to get started writing a State Machine with FlowRedux DSL. class MyStateMachine : FlowReduxStateMachine < State , Action > ( InitialState ){ init { spec { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } } } See DSL section for more information how to use the DSL. The advantage of extending from FlowReduxStateMachine is that you get a ready a base template where you just have to fill in the DSL part inside the spec { ... } block. By extending from FlowReduxStateMachine your StateMachine inherits a dispatch(action : Action) method to dispatch Actions to your state machine and a val state: Flow<State> to observe your state machine\u2019s state. Whenever the state changes, the latest State will be emitted to this Flow .","title":"FlowReduxStateMachine"},{"location":"flow_vs_FlowReduxStateMachine/#reduxstore","text":"If you want to work with Flow type directly FlowRedux provides you a custom operator called .reduxStore() . It is a custom operator like any other Flow operator like Flow.map { ... } . The idea is that the upstream Flow brings the actions to your FlowReduxStore like this: sealed class Action { object Action1 : MyAction () object Action2 : MyAction () } val actionFlow : Flow < Action > = flowOf { emit ( Action1 ) delay ( 2000 ) emit ( Action2 ) } val stateFlow : Flow < State > = actionFlow // actionFlow is the input actions to the state machine . reduxStore < Action , State > ( IntialState ) { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } stateFlow . collect { state -> updateUi ( state ) }","title":".reduxStore()"},{"location":"multiplatform/","text":"Multiplatform \u00b6 FlowRedux is supported on: JVM / Android iOS x64 iOS ARM64 + ARM 32 watchOS x86 watchOS ARM64 + ARM 32 tvOS x86 tvOS ARM64 + ARM 32 We do plan to add support for JavaScript but it\u2019s not available yet.","title":"Multiplatform"},{"location":"multiplatform/#multiplatform","text":"FlowRedux is supported on: JVM / Android iOS x64 iOS ARM64 + ARM 32 watchOS x86 watchOS ARM64 + ARM 32 tvOS x86 tvOS ARM64 + ARM 32 We do plan to add support for JavaScript but it\u2019s not available yet.","title":"Multiplatform"},{"location":"Javadoc/dsl/","text":"// dsl dsl \u00b6 Packages \u00b6 Name com.freeletics.flowredux.dsl com.freeletics.flowredux.dsl.internal","title":"Index"},{"location":"Javadoc/dsl/#dsl","text":"","title":"dsl"},{"location":"Javadoc/dsl/#packages","text":"Name com.freeletics.flowredux.dsl com.freeletics.flowredux.dsl.internal","title":"Packages"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/","text":"// dsl / com.freeletics.flowredux.dsl Package com.freeletics.flowredux.dsl \u00b6 Types \u00b6 Name Summary ChangeState [common] sealed class ChangeState S > Represents a state transition. FlatMapPolicy [common] enum FlatMapPolicy : Enum < FlatMapPolicy > Defines which flatMap behavior should be applied whenever a new values is emitted FlowReduxStateMachine [common] @FlowPreview() @ExperimentalCoroutinesApi() abstract class FlowReduxStateMachine < S : Any , A : Any >( initialState : S , scope : CoroutineScope, logger : FlowReduxLogger?) : StateMachine< S , A > FlowReduxStoreBuilder [common] @FlowPreview() @ExperimentalCoroutinesApi() class FlowReduxStoreBuilder < S : Any , A : Any > InStateBuilderBlock [common] @FlowPreview() @ExperimentalCoroutinesApi() class InStateBuilderBlock < InputState : S , S : Any , A : Any >( _isInState : ( S ) -> Boolean ) : StoreWideBuilderBlock < S , A > InStateObserverHandler [common] typealias InStateObserverHandler < T , InputState , S > = suspend ( T , InputState ) -> ChangeState < S > MutateState [common] class MutateState < InputState : S , S >( reducer : InputState .() -> S ) : ChangeState < S > Use this function if you want to \u201cmutate\u201d the current state by copying the old state and modify some properties in the copy of the new state. NoStateChange [common] object NoStateChange : ChangeState < Nothing > No change, this is semantically equivalent to use OverrideState and pass in the previous state OverrideState [common] data class OverrideState < S >( newState : S ) : ChangeState < S > Sets a new state by directly override any previous state StoreWideBuilderBlock [common] abstract class StoreWideBuilderBlock < S , A > It\u2019s just not an Interface to not expose internal class Action to the public. Functions \u00b6 Name Summary reduce [common] fun < S > ChangeState < S >. reduce (state: S ): S reduxStore [common] @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialState: S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialStateSupplier: () -> S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > Provides a fluent DSL to specify a ReduxStore","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/#package-comfreeleticsflowreduxdsl","text":"","title":"Package com.freeletics.flowredux.dsl"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/#types","text":"Name Summary ChangeState [common] sealed class ChangeState S > Represents a state transition. FlatMapPolicy [common] enum FlatMapPolicy : Enum < FlatMapPolicy > Defines which flatMap behavior should be applied whenever a new values is emitted FlowReduxStateMachine [common] @FlowPreview() @ExperimentalCoroutinesApi() abstract class FlowReduxStateMachine < S : Any , A : Any >( initialState : S , scope : CoroutineScope, logger : FlowReduxLogger?) : StateMachine< S , A > FlowReduxStoreBuilder [common] @FlowPreview() @ExperimentalCoroutinesApi() class FlowReduxStoreBuilder < S : Any , A : Any > InStateBuilderBlock [common] @FlowPreview() @ExperimentalCoroutinesApi() class InStateBuilderBlock < InputState : S , S : Any , A : Any >( _isInState : ( S ) -> Boolean ) : StoreWideBuilderBlock < S , A > InStateObserverHandler [common] typealias InStateObserverHandler < T , InputState , S > = suspend ( T , InputState ) -> ChangeState < S > MutateState [common] class MutateState < InputState : S , S >( reducer : InputState .() -> S ) : ChangeState < S > Use this function if you want to \u201cmutate\u201d the current state by copying the old state and modify some properties in the copy of the new state. NoStateChange [common] object NoStateChange : ChangeState < Nothing > No change, this is semantically equivalent to use OverrideState and pass in the previous state OverrideState [common] data class OverrideState < S >( newState : S ) : ChangeState < S > Sets a new state by directly override any previous state StoreWideBuilderBlock [common] abstract class StoreWideBuilderBlock < S , A > It\u2019s just not an Interface to not expose internal class Action to the public.","title":"Types"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/#functions","text":"Name Summary reduce [common] fun < S > ChangeState < S >. reduce (state: S ): S reduxStore [common] @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialState: S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialStateSupplier: () -> S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > Provides a fluent DSL to specify a ReduxStore","title":"Functions"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/reduce/","text":"// dsl / com.freeletics.flowredux.dsl / reduce reduce \u00b6 [common]\\ fun < S > ChangeState < S >. reduce (state: S ): S","title":"Reduce"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/reduce/#reduce","text":"[common]\\ fun < S > ChangeState < S >. reduce (state: S ): S","title":"reduce"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/redux-store/","text":"// dsl / com.freeletics.flowredux.dsl / reduxStore reduxStore \u00b6 [common]\\ @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialStateSupplier: () -> S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialState: S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > Provides a fluent DSL to specify a ReduxStore","title":"Redux store"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/redux-store/#reduxstore","text":"[common]\\ @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialStateSupplier: () -> S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > @FlowPreview() @ExperimentalCoroutinesApi() fun < S : Any , A : Any > Flow< A >. reduxStore (logger: FlowReduxLogger? = null, initialState: S , block: FlowReduxStoreBuilder < S , A >.() -> Unit ): Flow< S > Provides a fluent DSL to specify a ReduxStore","title":"reduxStore"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-change-state/","text":"// dsl / com.freeletics.flowredux.dsl / ChangeState ChangeState \u00b6 [common]\\ sealed class ChangeState S > Represents a state transition. Either use [MutateState](../-mutate-state/index.md) to mutate the current state. You get a lambda block with the current state as input and expects the next state as output. [OverrideState](../-override-state/index.md) to trigger a transition from one state to the next one by simply overriding whatever state was there before. Be careful using this especially if you have handle multiple actions or collect flows within the same state as it really overrides the full state and you may loose information or partial state changes triggered by them. Use [MutateState](../-mutate-state/index.md) in that case. [NoStateChange](../-no-state-change/index.md) to indicate that this function did not change the state at all. There should be only very little use case for [NoStateChange](../-no-state-change/index.md). So only use it if you actually know what you do. ChangeState doesnt allow you to directly access any property. Then you may wonder how do you write unit test for one of your functions that return a ChangeState ? You need to call ChangeState.reduce to get the actual result of the change state. Inheritors \u00b6 Name OverrideState MutateState NoStateChange Extensions \u00b6 Name Summary reduce [common] fun < S > ChangeState < S >. reduce (state: S ): S","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-change-state/#changestate","text":"[common]\\ sealed class ChangeState S > Represents a state transition. Either use [MutateState](../-mutate-state/index.md) to mutate the current state. You get a lambda block with the current state as input and expects the next state as output. [OverrideState](../-override-state/index.md) to trigger a transition from one state to the next one by simply overriding whatever state was there before. Be careful using this especially if you have handle multiple actions or collect flows within the same state as it really overrides the full state and you may loose information or partial state changes triggered by them. Use [MutateState](../-mutate-state/index.md) in that case. [NoStateChange](../-no-state-change/index.md) to indicate that this function did not change the state at all. There should be only very little use case for [NoStateChange](../-no-state-change/index.md). So only use it if you actually know what you do. ChangeState doesnt allow you to directly access any property. Then you may wonder how do you write unit test for one of your functions that return a ChangeState ? You need to call ChangeState.reduce to get the actual result of the change state.","title":"ChangeState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-change-state/#inheritors","text":"Name OverrideState MutateState NoStateChange","title":"Inheritors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-change-state/#extensions","text":"Name Summary reduce [common] fun < S > ChangeState < S >. reduce (state: S ): S","title":"Extensions"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy FlatMapPolicy \u00b6 [common]\\ enum FlatMapPolicy : Enum < FlatMapPolicy > Defines which flatMap behavior should be applied whenever a new values is emitted Entries \u00b6 CONCAT [common] CONCAT () Uses flatMapConcat MERGE [common] MERGE () Uses flatMapMerge LATEST [common] LATEST () uses flatMapLatest Properties \u00b6 Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/#flatmappolicy","text":"[common]\\ enum FlatMapPolicy : Enum < FlatMapPolicy > Defines which flatMap behavior should be applied whenever a new values is emitted","title":"FlatMapPolicy"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/#entries","text":"CONCAT [common] CONCAT () Uses flatMapConcat MERGE [common] MERGE () Uses flatMapMerge LATEST [common] LATEST () uses flatMapLatest","title":"Entries"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/#properties","text":"Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / CONCAT CONCAT \u00b6 [common]\\ CONCAT () Uses flatMapConcat Properties \u00b6 Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/#concat","text":"[common]\\ CONCAT () Uses flatMapConcat","title":"CONCAT"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/#properties","text":"Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/name/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / CONCAT / name name \u00b6 [common]\\ val name : String","title":"Name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/name/#name","text":"[common]\\ val name : String","title":"name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/ordinal/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / CONCAT / ordinal ordinal \u00b6 [common]\\ val ordinal : Int","title":"Ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/ordinal/#ordinal","text":"[common]\\ val ordinal : Int","title":"ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / LATEST LATEST \u00b6 [common]\\ LATEST () uses flatMapLatest Properties \u00b6 Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/#latest","text":"[common]\\ LATEST () uses flatMapLatest","title":"LATEST"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/#properties","text":"Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/name/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / LATEST / name name \u00b6 [common]\\ val name : String","title":"Name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/name/#name","text":"[common]\\ val name : String","title":"name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/ordinal/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / LATEST / ordinal ordinal \u00b6 [common]\\ val ordinal : Int","title":"Ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/ordinal/#ordinal","text":"[common]\\ val ordinal : Int","title":"ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / MERGE MERGE \u00b6 [common]\\ MERGE () Uses flatMapMerge Properties \u00b6 Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/#merge","text":"[common]\\ MERGE () Uses flatMapMerge","title":"MERGE"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/#properties","text":"Name Summary name [common] val name : String ordinal [common] val ordinal : Int","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/name/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / MERGE / name name \u00b6 [common]\\ val name : String","title":"Name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/name/#name","text":"[common]\\ val name : String","title":"name"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/ordinal/","text":"// dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / MERGE / ordinal ordinal \u00b6 [common]\\ val ordinal : Int","title":"Ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/ordinal/#ordinal","text":"[common]\\ val ordinal : Int","title":"ordinal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine FlowReduxStateMachine \u00b6 [common]\\ @FlowPreview() @ExperimentalCoroutinesApi() abstract class FlowReduxStateMachine < S : Any , A : Any >( initialState : S , scope : CoroutineScope, logger : FlowReduxLogger?) : StateMachine< S , A > Functions \u00b6 Name Summary dispatch [common] open suspend override fun dispatch (action: A ) Properties \u00b6 Name Summary state [common] open override val state : StateFlow< S >","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#flowreduxstatemachine","text":"[common]\\ @FlowPreview() @ExperimentalCoroutinesApi() abstract class FlowReduxStateMachine < S : Any , A : Any >( initialState : S , scope : CoroutineScope, logger : FlowReduxLogger?) : StateMachine< S , A >","title":"FlowReduxStateMachine"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#functions","text":"Name Summary dispatch [common] open suspend override fun dispatch (action: A )","title":"Functions"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#properties","text":"Name Summary state [common] open override val state : StateFlow< S >","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/-flow-redux-state-machine/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / FlowReduxStateMachine FlowReduxStateMachine \u00b6 [common]\\ fun < S : Any > FlowReduxStateMachine (initialState: S , scope: CoroutineScope, logger: FlowReduxLogger? = null)","title":" flow redux state machine"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/-flow-redux-state-machine/#flowreduxstatemachine","text":"[common]\\ fun < S : Any > FlowReduxStateMachine (initialState: S , scope: CoroutineScope, logger: FlowReduxLogger? = null)","title":"FlowReduxStateMachine"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/dispatch/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / dispatch dispatch \u00b6 [common]\\ open suspend override fun dispatch (action: A )","title":"Dispatch"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/dispatch/#dispatch","text":"[common]\\ open suspend override fun dispatch (action: A )","title":"dispatch"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/state/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / state state \u00b6 [common]\\ open override val state : StateFlow< S >","title":"State"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/state/#state","text":"[common]\\ open override val state : StateFlow< S >","title":"state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder FlowReduxStoreBuilder \u00b6 [common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class FlowReduxStoreBuilder < S : Any , A : Any > Functions \u00b6 Name Summary inState [common] inline fun < SubState : S > inState (noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) Define what happens if the store is in a certain state. [common] inline fun < SubState : S > inState (noinline additionalIsInState: ( SubState ) -> Boolean , noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) This variation allows you to specify is a mix between inferring the condition of the generic function type and additionally can specify and ADDITIONAL condition that also must be true in addition to the check that the type as specified as generic fun parameter is an instance of the current state. inStateWithCondition [common] fun inStateWithCondition (isInState: ( S ) -> Boolean , block: InStateBuilderBlock < S , S , A >.() -> Unit ) Define what happens if the store is in a certain state. Properties \u00b6 Name Summary builderBlocks [common] val builderBlocks : MutableList < StoreWideBuilderBlock < S , A >>","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#flowreduxstorebuilder","text":"[common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class FlowReduxStoreBuilder < S : Any , A : Any >","title":"FlowReduxStoreBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#functions","text":"Name Summary inState [common] inline fun < SubState : S > inState (noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) Define what happens if the store is in a certain state. [common] inline fun < SubState : S > inState (noinline additionalIsInState: ( SubState ) -> Boolean , noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) This variation allows you to specify is a mix between inferring the condition of the generic function type and additionally can specify and ADDITIONAL condition that also must be true in addition to the check that the type as specified as generic fun parameter is an instance of the current state. inStateWithCondition [common] fun inStateWithCondition (isInState: ( S ) -> Boolean , block: InStateBuilderBlock < S , S , A >.() -> Unit ) Define what happens if the store is in a certain state.","title":"Functions"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#properties","text":"Name Summary builderBlocks [common] val builderBlocks : MutableList < StoreWideBuilderBlock < S , A >>","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/-flow-redux-store-builder/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / FlowReduxStoreBuilder FlowReduxStoreBuilder \u00b6 [common]\\ fun FlowReduxStoreBuilder ()","title":" flow redux store builder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/-flow-redux-store-builder/#flowreduxstorebuilder","text":"[common]\\ fun FlowReduxStoreBuilder ()","title":"FlowReduxStoreBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/builder-blocks/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / builderBlocks builderBlocks \u00b6 [common]\\ val builderBlocks : MutableList < StoreWideBuilderBlock < S , A >>","title":"Builder blocks"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/builder-blocks/#builderblocks","text":"[common]\\ val builderBlocks : MutableList < StoreWideBuilderBlock < S , A >>","title":"builderBlocks"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state-with-condition/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / inStateWithCondition inStateWithCondition \u00b6 [common]\\ fun inStateWithCondition (isInState: ( S ) -> Boolean , block: InStateBuilderBlock < S , S , A >.() -> Unit ) Define what happens if the store is in a certain state. Parameters \u00b6 common isInState The condition under which we identify that the state machine is in a given \u201cstate\u201d.","title":"In state with condition"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state-with-condition/#instatewithcondition","text":"[common]\\ fun inStateWithCondition (isInState: ( S ) -> Boolean , block: InStateBuilderBlock < S , S , A >.() -> Unit ) Define what happens if the store is in a certain state.","title":"inStateWithCondition"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state-with-condition/#parameters","text":"common isInState The condition under which we identify that the state machine is in a given \u201cstate\u201d.","title":"Parameters"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state/","text":"// dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / inState inState \u00b6 [common]\\ inline fun < SubState : S > inState (noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) Define what happens if the store is in a certain state. \u201cIn a certain state\u201d condition is true if state is instance of the type specified as generic function parameter. [common]\\ inline fun < SubState : S > inState (noinline additionalIsInState: ( SubState ) -> Boolean , noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) This variation allows you to specify is a mix between inferring the condition of the generic function type and additionally can specify and ADDITIONAL condition that also must be true in addition to the check that the type as specified as generic fun parameter is an instance of the current state.","title":"In state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state/#instate","text":"[common]\\ inline fun < SubState : S > inState (noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) Define what happens if the store is in a certain state. \u201cIn a certain state\u201d condition is true if state is instance of the type specified as generic function parameter. [common]\\ inline fun < SubState : S > inState (noinline additionalIsInState: ( SubState ) -> Boolean , noinline block: InStateBuilderBlock < SubState , S , A >.() -> Unit ) This variation allows you to specify is a mix between inferring the condition of the generic function type and additionally can specify and ADDITIONAL condition that also must be true in addition to the check that the type as specified as generic fun parameter is an instance of the current state.","title":"inState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock InStateBuilderBlock \u00b6 [common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class InStateBuilderBlock < InputState : S , S : Any , A : Any >( _isInState : ( S ) -> Boolean ) : StoreWideBuilderBlock < S , A > Functions \u00b6 Name Summary collectWhileInState [common] fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flow: Flow< T >, handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flow: Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. on [common] inline fun < SubAction : A > on (noinline handler: OnActionHandler < InputState , S , SubAction >) inline fun < SubAction : A > on (flatMapPolicy: FlatMapPolicy , noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. onEnter [common] fun onEnter (handler: InStateOnEnterHandler < InputState , S >) Triggers every time the state machine enters this state. Properties \u00b6 Name Summary _inStateSideEffectBuilders [common] val _inStateSideEffectBuilders : ArrayList < InStateSideEffectBuilder < InputState , S , A >> _isInState [common] val _isInState : ( S ) -> Boolean For private usage only","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#instatebuilderblock","text":"[common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class InStateBuilderBlock < InputState : S , S : Any , A : Any >( _isInState : ( S ) -> Boolean ) : StoreWideBuilderBlock < S , A >","title":"InStateBuilderBlock"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#functions","text":"Name Summary collectWhileInState [common] fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flow: Flow< T >, handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) fun < T > collectWhileInState (flow: Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. on [common] inline fun < SubAction : A > on (noinline handler: OnActionHandler < InputState , S , SubAction >) inline fun < SubAction : A > on (flatMapPolicy: FlatMapPolicy , noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. onEnter [common] fun onEnter (handler: InStateOnEnterHandler < InputState , S >) Triggers every time the state machine enters this state.","title":"Functions"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#properties","text":"Name Summary _inStateSideEffectBuilders [common] val _inStateSideEffectBuilders : ArrayList < InStateSideEffectBuilder < InputState , S , A >> _isInState [common] val _isInState : ( S ) -> Boolean For private usage only","title":"Properties"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/-in-state-builder-block/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / InStateBuilderBlock InStateBuilderBlock \u00b6 [common]\\ fun < S : Any > InStateBuilderBlock (_isInState: ( S ) -> Boolean )","title":" in state builder block"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/-in-state-builder-block/#instatebuilderblock","text":"[common]\\ fun < S : Any > InStateBuilderBlock (_isInState: ( S ) -> Boolean )","title":"InStateBuilderBlock"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_in-state-side-effect-builders/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / _inStateSideEffectBuilders _inStateSideEffectBuilders \u00b6 [common]\\ val _inStateSideEffectBuilders : ArrayList < InStateSideEffectBuilder < InputState , S , A >>","title":" in state side effect builders"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_in-state-side-effect-builders/#_instatesideeffectbuilders","text":"[common]\\ val _inStateSideEffectBuilders : ArrayList < InStateSideEffectBuilder < InputState , S , A >>","title":"_inStateSideEffectBuilders"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_is-in-state/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / _isInState _isInState \u00b6 [common]\\ val _isInState : ( S ) -> Boolean For private usage only","title":" is in state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_is-in-state/#_isinstate","text":"[common]\\ val _isInState : ( S ) -> Boolean For private usage only","title":"_isInState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/collect-while-in-state/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / collectWhileInState collectWhileInState \u00b6 [common]\\ fun < T > collectWhileInState (flow: Flow< T >, handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. The passed flow will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. handler will only be called for a new emission from flow after a previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flow: Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. The passed flow will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new emission from flow arrives before the previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. flowBuilder will get a Flow that emits the current InputState and any change to it. The transformed Flow that flowBuilder returns will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. handler will only be called for a new emission from flowBuilder \u2018s Flow after a previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. flowBuilder will get a Flow that emits the current InputState and any change to it. The transformed Flow that flowBuilder returns will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new emission from flowBuilder \u2018s Flow arrives before the previous handler invocation completed.","title":"Collect while in state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/collect-while-in-state/#collectwhileinstate","text":"[common]\\ fun < T > collectWhileInState (flow: Flow< T >, handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. The passed flow will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. handler will only be called for a new emission from flow after a previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flow: Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. The passed flow will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new emission from flow arrives before the previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. flowBuilder will get a Flow that emits the current InputState and any change to it. The transformed Flow that flowBuilder returns will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. handler will only be called for a new emission from flowBuilder \u2018s Flow after a previous handler invocation completed. [common]\\ fun < T > collectWhileInState (flowBuilder: (Flow< InputState >) -> Flow< T >, flatMapPolicy: FlatMapPolicy , handler: InStateObserverHandler < T , InputState , S >) Triggers every time the state machine enters this state. flowBuilder will get a Flow that emits the current InputState and any change to it. The transformed Flow that flowBuilder returns will be collected and any emission will be passed to handler . The collection as well as any ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new emission from flowBuilder \u2018s Flow arrives before the previous handler invocation completed.","title":"collectWhileInState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on-enter/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / onEnter onEnter \u00b6 [common]\\ fun onEnter (handler: InStateOnEnterHandler < InputState , S >) Triggers every time the state machine enters this state. An ongoing handler is cancelled when leaving this state.","title":"On enter"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on-enter/#onenter","text":"[common]\\ fun onEnter (handler: InStateOnEnterHandler < InputState , S >) Triggers every time the state machine enters this state. An ongoing handler is cancelled when leaving this state.","title":"onEnter"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on/","text":"// dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / on on \u00b6 [common]\\ inline fun < SubAction : A > on (noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. An ongoing handler is cancelled when leaving this state or when a new SubAction is dispatched. [common]\\ inline fun < SubAction : A > on (flatMapPolicy: FlatMapPolicy , noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. An ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new SubAction is dispatched while the previous handler execution is still ongoing.","title":"On"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on/#on","text":"[common]\\ inline fun < SubAction : A > on (noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. An ongoing handler is cancelled when leaving this state or when a new SubAction is dispatched. [common]\\ inline fun < SubAction : A > on (flatMapPolicy: FlatMapPolicy , noinline handler: OnActionHandler < InputState , S , SubAction >) Triggers every time an action of type SubAction is dispatched while the state machine is in this state. An ongoing handler is cancelled when leaving this state. flatMapPolicy is used to determine the behavior when a new SubAction is dispatched while the previous handler execution is still ongoing.","title":"on"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-mutate-state/","text":"// dsl / com.freeletics.flowredux.dsl / MutateState MutateState \u00b6 [common]\\ class MutateState < InputState : S , S >( reducer : InputState .() -> S ) : ChangeState < S > Use this function if you want to \u201cmutate\u201d the current state by copying the old state and modify some properties in the copy of the new state. A common use case is to call .copy() on your state defined as data class. Constructors \u00b6 MutateState [common] fun < InputState : S , S > MutateState (reducer: InputState .() -> S )","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-mutate-state/#mutatestate","text":"[common]\\ class MutateState < InputState : S , S >( reducer : InputState .() -> S ) : ChangeState < S > Use this function if you want to \u201cmutate\u201d the current state by copying the old state and modify some properties in the copy of the new state. A common use case is to call .copy() on your state defined as data class.","title":"MutateState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-mutate-state/#constructors","text":"MutateState [common] fun < InputState : S , S > MutateState (reducer: InputState .() -> S )","title":"Constructors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-mutate-state/-mutate-state/","text":"// dsl / com.freeletics.flowredux.dsl / MutateState / MutateState MutateState \u00b6 [common]\\ fun < InputState : S , S > MutateState (reducer: InputState .() -> S )","title":" mutate state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-mutate-state/-mutate-state/#mutatestate","text":"[common]\\ fun < InputState : S , S > MutateState (reducer: InputState .() -> S )","title":"MutateState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-no-state-change/","text":"// dsl / com.freeletics.flowredux.dsl / NoStateChange NoStateChange \u00b6 [common]\\ object NoStateChange : ChangeState < Nothing > No change, this is semantically equivalent to use OverrideState and pass in the previous state","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-no-state-change/#nostatechange","text":"[common]\\ object NoStateChange : ChangeState < Nothing > No change, this is semantically equivalent to use OverrideState and pass in the previous state","title":"NoStateChange"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-override-state/","text":"// dsl / com.freeletics.flowredux.dsl / OverrideState OverrideState \u00b6 [common]\\ data class OverrideState < S >( newState : S ) : ChangeState < S > Sets a new state by directly override any previous state Constructors \u00b6 OverrideState [common] fun < S > OverrideState (newState: S )","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-override-state/#overridestate","text":"[common]\\ data class OverrideState < S >( newState : S ) : ChangeState < S > Sets a new state by directly override any previous state","title":"OverrideState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-override-state/#constructors","text":"OverrideState [common] fun < S > OverrideState (newState: S )","title":"Constructors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-override-state/-override-state/","text":"// dsl / com.freeletics.flowredux.dsl / OverrideState / OverrideState OverrideState \u00b6 [common]\\ fun < S > OverrideState (newState: S )","title":" override state"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-override-state/-override-state/#overridestate","text":"[common]\\ fun < S > OverrideState (newState: S )","title":"OverrideState"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/","text":"// dsl / com.freeletics.flowredux.dsl / StoreWideBuilderBlock StoreWideBuilderBlock \u00b6 [common]\\ abstract class StoreWideBuilderBlock < S , A > It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. It\u2019s also not a sealed class because no need for it (no need to enumerate subclasses as we only care about the abstract functions this class exposes). Also sealed class would mean to move all subclasses into the same File. That is not that nice as it all subclasses are implementation detail heavy. There is no need to have a hundreds of lines of code in one file just to have sealed classes. Inheritors \u00b6 Name InStateBuilderBlock","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/#storewidebuilderblock","text":"[common]\\ abstract class StoreWideBuilderBlock < S , A > It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. It\u2019s also not a sealed class because no need for it (no need to enumerate subclasses as we only care about the abstract functions this class exposes). Also sealed class would mean to move all subclasses into the same File. That is not that nice as it all subclasses are implementation detail heavy. There is no need to have a hundreds of lines of code in one file just to have sealed classes.","title":"StoreWideBuilderBlock"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/#inheritors","text":"Name InStateBuilderBlock","title":"Inheritors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/","text":"// dsl / com.freeletics.flowredux.dsl.internal Package com.freeletics.flowredux.dsl.internal \u00b6 Types \u00b6 Name Summary InStateOnEnterHandler [common] typealias InStateOnEnterHandler < InputState , S > = suspend ( InputState ) -> ChangeState < S > InStateSideEffectBuilder [common] abstract class InStateSideEffectBuilder < InputState : S , S , A > It\u2019s just not an Interface to not expose internal class Action to the public. OnActionHandler [common] typealias OnActionHandler < InputState , S , A > = suspend ( A , InputState ) -> ChangeState < S > OnActionInStateSideEffectBuilder [common] @FlowPreview() @ExperimentalCoroutinesApi() class OnActionInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , subActionClass : KClass A >, flatMapPolicy : FlatMapPolicy , handler : OnActionHandler < InputState , S , A >) : InStateSideEffectBuilder < InputState , S , A > OnEnterInStateSideEffectBuilder [common] class OnEnterInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , handler : InStateOnEnterHandler < InputState , S >) : InStateSideEffectBuilder < InputState , S , A > A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/#package-comfreeleticsflowreduxdslinternal","text":"","title":"Package com.freeletics.flowredux.dsl.internal"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/#types","text":"Name Summary InStateOnEnterHandler [common] typealias InStateOnEnterHandler < InputState , S > = suspend ( InputState ) -> ChangeState < S > InStateSideEffectBuilder [common] abstract class InStateSideEffectBuilder < InputState : S , S , A > It\u2019s just not an Interface to not expose internal class Action to the public. OnActionHandler [common] typealias OnActionHandler < InputState , S , A > = suspend ( A , InputState ) -> ChangeState < S > OnActionInStateSideEffectBuilder [common] @FlowPreview() @ExperimentalCoroutinesApi() class OnActionInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , subActionClass : KClass A >, flatMapPolicy : FlatMapPolicy , handler : OnActionHandler < InputState , S , A >) : InStateSideEffectBuilder < InputState , S , A > OnEnterInStateSideEffectBuilder [common] class OnEnterInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , handler : InStateOnEnterHandler < InputState , S >) : InStateSideEffectBuilder < InputState , S , A > A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":"Types"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-in-state-side-effect-builder/","text":"// dsl / com.freeletics.flowredux.dsl.internal / InStateSideEffectBuilder InStateSideEffectBuilder \u00b6 [common]\\ abstract class InStateSideEffectBuilder < InputState : S , S , A > It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. Inheritors \u00b6 Name OnActionInStateSideEffectBuilder OnEnterInStateSideEffectBuilder","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-in-state-side-effect-builder/#instatesideeffectbuilder","text":"[common]\\ abstract class InStateSideEffectBuilder < InputState : S , S , A > It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface.","title":"InStateSideEffectBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-in-state-side-effect-builder/#inheritors","text":"Name OnActionInStateSideEffectBuilder OnEnterInStateSideEffectBuilder","title":"Inheritors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-action-in-state-side-effect-builder/","text":"// dsl / com.freeletics.flowredux.dsl.internal / OnActionInStateSideEffectBuilder OnActionInStateSideEffectBuilder \u00b6 [common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class OnActionInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , subActionClass : KClass A >, flatMapPolicy : FlatMapPolicy , handler : OnActionHandler < InputState , S , A >) : InStateSideEffectBuilder < InputState , S , A >","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-action-in-state-side-effect-builder/#onactioninstatesideeffectbuilder","text":"[common]\\ @FlowPreview() @ExperimentalCoroutinesApi() class OnActionInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , subActionClass : KClass A >, flatMapPolicy : FlatMapPolicy , handler : OnActionHandler < InputState , S , A >) : InStateSideEffectBuilder < InputState , S , A >","title":"OnActionInStateSideEffectBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-action-in-state-side-effect-builder/-on-action-in-state-side-effect-builder/","text":"// dsl / com.freeletics.flowredux.dsl.internal / OnActionInStateSideEffectBuilder / OnActionInStateSideEffectBuilder OnActionInStateSideEffectBuilder \u00b6 [common]\\ fun < S : Any , A : Any > OnActionInStateSideEffectBuilder (isInState: ( S ) -> Boolean , subActionClass: KClass A >, flatMapPolicy: FlatMapPolicy , handler: OnActionHandler < InputState , S , A >)","title":" on action in state side effect builder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-action-in-state-side-effect-builder/-on-action-in-state-side-effect-builder/#onactioninstatesideeffectbuilder","text":"[common]\\ fun < S : Any , A : Any > OnActionInStateSideEffectBuilder (isInState: ( S ) -> Boolean , subActionClass: KClass A >, flatMapPolicy: FlatMapPolicy , handler: OnActionHandler < InputState , S , A >)","title":"OnActionInStateSideEffectBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-enter-in-state-side-effect-builder/","text":"// dsl / com.freeletics.flowredux.dsl.internal / OnEnterInStateSideEffectBuilder OnEnterInStateSideEffectBuilder \u00b6 [common]\\ class OnEnterInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , handler : InStateOnEnterHandler < InputState , S >) : InStateSideEffectBuilder < InputState , S , A > A builder that generates a SideEffect that triggers every time the state machine enters a certain state. Constructors \u00b6 OnEnterInStateSideEffectBuilder [common] fun < S : Any > OnEnterInStateSideEffectBuilder (isInState: ( S ) -> Boolean , handler: InStateOnEnterHandler < InputState , S >)","title":"Index"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-enter-in-state-side-effect-builder/#onenterinstatesideeffectbuilder","text":"[common]\\ class OnEnterInStateSideEffectBuilder < InputState : S , S : Any , A : Any >( isInState : ( S ) -> Boolean , handler : InStateOnEnterHandler < InputState , S >) : InStateSideEffectBuilder < InputState , S , A > A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":"OnEnterInStateSideEffectBuilder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-enter-in-state-side-effect-builder/#constructors","text":"OnEnterInStateSideEffectBuilder [common] fun < S : Any > OnEnterInStateSideEffectBuilder (isInState: ( S ) -> Boolean , handler: InStateOnEnterHandler < InputState , S >)","title":"Constructors"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-enter-in-state-side-effect-builder/-on-enter-in-state-side-effect-builder/","text":"// dsl / com.freeletics.flowredux.dsl.internal / OnEnterInStateSideEffectBuilder / OnEnterInStateSideEffectBuilder OnEnterInStateSideEffectBuilder \u00b6 [common]\\ fun < S : Any > OnEnterInStateSideEffectBuilder (isInState: ( S ) -> Boolean , handler: InStateOnEnterHandler < InputState , S >)","title":" on enter in state side effect builder"},{"location":"Javadoc/dsl/dsl/com.freeletics.flowredux.dsl.internal/-on-enter-in-state-side-effect-builder/-on-enter-in-state-side-effect-builder/#onenterinstatesideeffectbuilder","text":"[common]\\ fun < S : Any > OnEnterInStateSideEffectBuilder (isInState: ( S ) -> Boolean , handler: InStateOnEnterHandler < InputState , S >)","title":"OnEnterInStateSideEffectBuilder"},{"location":"Javadoc/flowredux/","text":"// flowredux flowredux \u00b6 Packages \u00b6 Name com.freeletics.flowredux","title":"Index"},{"location":"Javadoc/flowredux/#flowredux","text":"","title":"flowredux"},{"location":"Javadoc/flowredux/#packages","text":"Name com.freeletics.flowredux","title":"Packages"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/","text":"// flowredux / com.freeletics.flowredux Package com.freeletics.flowredux \u00b6 Types \u00b6 Name Summary FlowReduxLogger [common] interface FlowReduxLogger GetState [common] typealias GetState < S > = () -> S The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. Reducer [common] typealias Reducer < S , A > = ( S , A ) -> S A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. If a reducer should not react on a Action, just return the old State. SideEffect [common] typealias SideEffect < S , A > = (actions: Flow< A >, getState: GetState < S >) -> Flow< A > It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics). Functions \u00b6 Name Summary reduxStore [common] @ExperimentalCoroutinesApi() fun < A , S > Flow< A >. reduxStore (initialStateSupplier: () -> S , sideEffects: Iterable < SideEffect < S , A >>, logger: FlowReduxLogger ? = null, reducer: Reducer < S , A >): Flow< S > Creates a Redux store with a initialStateSupplier that produces the first state lazily once the flow starts.","title":"Index"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/#package-comfreeleticsflowredux","text":"","title":"Package com.freeletics.flowredux"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/#types","text":"Name Summary FlowReduxLogger [common] interface FlowReduxLogger GetState [common] typealias GetState < S > = () -> S The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. Reducer [common] typealias Reducer < S , A > = ( S , A ) -> S A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. If a reducer should not react on a Action, just return the old State. SideEffect [common] typealias SideEffect < S , A > = (actions: Flow< A >, getState: GetState < S >) -> Flow< A > It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics).","title":"Types"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/#functions","text":"Name Summary reduxStore [common] @ExperimentalCoroutinesApi() fun < A , S > Flow< A >. reduxStore (initialStateSupplier: () -> S , sideEffects: Iterable < SideEffect < S , A >>, logger: FlowReduxLogger ? = null, reducer: Reducer < S , A >): Flow< S > Creates a Redux store with a initialStateSupplier that produces the first state lazily once the flow starts.","title":"Functions"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/redux-store/","text":"// flowredux / com.freeletics.flowredux / reduxStore reduxStore \u00b6 [common]\\ @ExperimentalCoroutinesApi() fun < A , S > Flow< A >. reduxStore (initialStateSupplier: () -> S , sideEffects: Iterable < SideEffect < S , A >>, logger: FlowReduxLogger ? = null, reducer: Reducer < S , A >): Flow< S > Creates a Redux store with a initialStateSupplier that produces the first state lazily once the flow starts.","title":"Redux store"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/redux-store/#reduxstore","text":"[common]\\ @ExperimentalCoroutinesApi() fun < A , S > Flow< A >. reduxStore (initialStateSupplier: () -> S , sideEffects: Iterable < SideEffect < S , A >>, logger: FlowReduxLogger ? = null, reducer: Reducer < S , A >): Flow< S > Creates a Redux store with a initialStateSupplier that produces the first state lazily once the flow starts.","title":"reduxStore"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/-flow-redux-logger/","text":"// flowredux / com.freeletics.flowredux / FlowReduxLogger FlowReduxLogger \u00b6 [common]\\ interface FlowReduxLogger Functions \u00b6 Name Summary log [common] abstract fun log (message: String )","title":"Index"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/-flow-redux-logger/#flowreduxlogger","text":"[common]\\ interface FlowReduxLogger","title":"FlowReduxLogger"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/-flow-redux-logger/#functions","text":"Name Summary log [common] abstract fun log (message: String )","title":"Functions"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/-flow-redux-logger/log/","text":"// flowredux / com.freeletics.flowredux / FlowReduxLogger / log log \u00b6 [common]\\ abstract fun log (message: String )","title":"Log"},{"location":"Javadoc/flowredux/flowredux/com.freeletics.flowredux/-flow-redux-logger/log/#log","text":"[common]\\ abstract fun log (message: String )","title":"log"}]}