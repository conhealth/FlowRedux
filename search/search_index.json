{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"FlowRedux \u00b6 Building async. running Kotlin Multiplatform state machine made easy with a DSL and coroutines. Usage \u00b6 sealed class State object LoadingState : State () data class ContentState ( val items : List < Item >) : State () data class ErrorState ( val error : Throwable ) : State () sealed class Action object RetryLoadingAction : Action () class MyStateMachine : FlowReduxStateMachine < State , Action >( LoadingState ){ init { spec { inState < LoadingState > { onEnter { getState , setState -> // executes this block whenever we enter LoadingState try { val items = loadItems () // suspending function / coroutine to load items setState { ContentState ( items ) } // Transition to ContentState } catch ( t : Throwable ) { setState { ErrorState ( t ) } // Transition to ErrorState } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> // executes this block whenever // ErrorState is current state and RetryLoadingAction is emitted setState { LoadingState } // Transition to LoadingState which loads list again } } inState < ContentState > { collectWhileInState ( flowOf ( 1 , 2 , 3 ) ) { getState , setState -> // observes the given flow as long as state is ContentState. // Once state is changed to another state the flow will automatically // stop emitting. } } } } } val statemachine = MyStateMachine () launch { // Launch a coroutine statemachine . state . collect { state -> // do something with new state like update UI renderUI ( state ) } } // emit an Action launch { // Launch a coroutine statemachine . dispatch ( Action ) } In an Android Application you would use it with AndroidX ViewModel like that: class MyViewModel @Inject constructor ( private val stateMachine : StateMachine ) : ViewModel () { val state : LiveData < State > = MutableLiveData < State >() init { viewModelScope . launch { // automatically canceled once ViewModel lifecycle reached destroyed. stateMachine . state . collect { newState -> state . value = newState } } } fun dispatch ( action : Action ) { viewModelScope . launch { stateMachine . dispatch ( action ) } } } Dependencies \u00b6 There are two artifacts that you can include as dependency:: 1. flowredux : this is the core library. Usually you dont want to use the core library directly but rather use the dsl . 2. dsl which provides a convenient DSL on top of the core library. Usually this is what you want. implementation 'com.freeletics.flowredux:flowredux-multiplatform:0.3.0' implementation 'com.freeletics.flowredux:dsl-multiplatform:0.3.0' JVM only \u00b6 implementation 'com.freeletics.flowredux:flowredux:0.3.0' implementation 'com.freeletics.flowredux:dsl:0.3.0' Native binaries \u00b6 implementation 'com.freeletics.flowredux:flowredux-iosx64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-iosarm64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-iosarm32:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosx86:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm32:0.3.0' implementation 'com.freeletics.flowredux:flowredux-tvosx64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-tvosxarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosx64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosarm32:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosx86:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosarm32:0.3.0' implementation 'com.freeletics.flowredux:dsl-tvosx64:0.3.0' implementation 'com.freeletics.flowredux:dsl-tvosxarm64:0.3.0' JavaScript \u00b6 No javascript version release yet but its on our TODO list. Snapshot \u00b6 Latest snapshot (directly published from master branch from Travis CI): allprojects { repositories { // Your repositories. // ... // Add url to snapshot repository maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } } Then just use -SNAPSHOT suffix as version like implementation 'com.freeletics.flowredux:dsl:0.3.1-SNAPSHOT'","title":"FlowRedux"},{"location":"#flowredux","text":"Building async. running Kotlin Multiplatform state machine made easy with a DSL and coroutines.","title":"FlowRedux"},{"location":"#usage","text":"sealed class State object LoadingState : State () data class ContentState ( val items : List < Item >) : State () data class ErrorState ( val error : Throwable ) : State () sealed class Action object RetryLoadingAction : Action () class MyStateMachine : FlowReduxStateMachine < State , Action >( LoadingState ){ init { spec { inState < LoadingState > { onEnter { getState , setState -> // executes this block whenever we enter LoadingState try { val items = loadItems () // suspending function / coroutine to load items setState { ContentState ( items ) } // Transition to ContentState } catch ( t : Throwable ) { setState { ErrorState ( t ) } // Transition to ErrorState } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> // executes this block whenever // ErrorState is current state and RetryLoadingAction is emitted setState { LoadingState } // Transition to LoadingState which loads list again } } inState < ContentState > { collectWhileInState ( flowOf ( 1 , 2 , 3 ) ) { getState , setState -> // observes the given flow as long as state is ContentState. // Once state is changed to another state the flow will automatically // stop emitting. } } } } } val statemachine = MyStateMachine () launch { // Launch a coroutine statemachine . state . collect { state -> // do something with new state like update UI renderUI ( state ) } } // emit an Action launch { // Launch a coroutine statemachine . dispatch ( Action ) } In an Android Application you would use it with AndroidX ViewModel like that: class MyViewModel @Inject constructor ( private val stateMachine : StateMachine ) : ViewModel () { val state : LiveData < State > = MutableLiveData < State >() init { viewModelScope . launch { // automatically canceled once ViewModel lifecycle reached destroyed. stateMachine . state . collect { newState -> state . value = newState } } } fun dispatch ( action : Action ) { viewModelScope . launch { stateMachine . dispatch ( action ) } } }","title":"Usage"},{"location":"#dependencies","text":"There are two artifacts that you can include as dependency:: 1. flowredux : this is the core library. Usually you dont want to use the core library directly but rather use the dsl . 2. dsl which provides a convenient DSL on top of the core library. Usually this is what you want. implementation 'com.freeletics.flowredux:flowredux-multiplatform:0.3.0' implementation 'com.freeletics.flowredux:dsl-multiplatform:0.3.0'","title":"Dependencies"},{"location":"#jvm-only","text":"implementation 'com.freeletics.flowredux:flowredux:0.3.0' implementation 'com.freeletics.flowredux:dsl:0.3.0'","title":"JVM only"},{"location":"#native-binaries","text":"implementation 'com.freeletics.flowredux:flowredux-iosx64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-iosarm64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-iosarm32:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosx86:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-watchosarm32:0.3.0' implementation 'com.freeletics.flowredux:flowredux-tvosx64:0.3.0' implementation 'com.freeletics.flowredux:flowredux-tvosxarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosx64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-iosarm32:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosx86:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosarm64:0.3.0' implementation 'com.freeletics.flowredux:dsl-watchosarm32:0.3.0' implementation 'com.freeletics.flowredux:dsl-tvosx64:0.3.0' implementation 'com.freeletics.flowredux:dsl-tvosxarm64:0.3.0'","title":"Native binaries"},{"location":"#javascript","text":"No javascript version release yet but its on our TODO list.","title":"JavaScript"},{"location":"#snapshot","text":"Latest snapshot (directly published from master branch from Travis CI): allprojects { repositories { // Your repositories. // ... // Add url to snapshot repository maven { url \"https://oss.sonatype.org/content/repositories/snapshots/\" } } } Then just use -SNAPSHOT suffix as version like implementation 'com.freeletics.flowredux:dsl:0.3.1-SNAPSHOT'","title":"Snapshot"},{"location":"contributing/","text":"Contributing \u00b6 To be done.","title":"Contributing"},{"location":"contributing/#contributing","text":"To be done.","title":"Contributing"},{"location":"dsl/","text":"DSL Guide \u00b6 FlowRedux provides a convenient DSL to describe your state machine. This page introduces you the DSL that you can use. To do that we will stick with a simple example of loading a list of items from a web service. As you read this section and more concepts of the DSL will be introduced we will extend this sample. For now to get started, let\u2019s define the States our state machine has. As said before we loads a list of items from a web service and display that list. While loading the list we show a loading indicator on the screen and if an error occurs we show an error message on the screen with a retry button. This gives us the following states: sealed class State { // Shows a loading indicator on screen object LoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item >) : State () // Error while loading happened data class ErrorState ( val cause : Throwable ) : State () } If we reached ErrorState we display an error message but also a button a user can click to retry loading the items. This gives us the following Actions : sealed class Action { object RetryLoadingAction : Action () } Initial State \u00b6 Every FlowReduxStateMachine needs an initial state. This is in which state the state machine starts. In our example we start with the LoadingState . class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { // will be filled in next section ... } } } Please note the constructor parameter of FlowReduxStateMachine(initialState = ...) . This is how you define the initial state of your state machine. Next, we already see that we need an init {...} block containing a spec { ... } block inside. The spec { ... } block is actually where we write our DSL inside. inState <State> \u00b6 The first concept we learn is inState class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { ... } } } } Please note that inState itself doesn\u2019t do anything. All we did so far with inState<LoadingState> is set an entry point. Next let\u2019s discuss what an inState can contain as triggers to actually \u201cdo something\u201d: onEnter : Triggers whenever we enter that state on<Action> : Triggers whenever we are in this state and the specified action is triggered from the outside by calling FlowReduxStateMachine.dispatch(action) . collectWhileInState( flow ) : You can subscribe to any arbitrary Flow while your state machine is in that state. Let\u2019s try to go through them as we build our state machine: onEnter \u00b6 What do we want to do when we enter the LoadingState ? We want to do the http request, right? Let\u2019s do that by extending our example: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( t ) } } } } } } } There are a some new things like onEnter , getState and setState . We will cover getState and setState in dedicated sections. All you have to know about setState for now is that this is the way to set the next state in your state machine. Let\u2019s talk about onEnter : onEnter { ... } is running asynchronously in a coroutine . That means whatever you do inside the onEnter block is not blocking anything else. You can totally run here long running and expensive calls (like doing an http request). onEnter { ... } doesn\u2019t get canceled when the state machine transitioned to another state original state. Example: inState < LoadingState > { onEnter { getState , setState -> setState { ErrorState ( Exception ( \"Fake Exception\" ) } doA () doSomethingLongRunning () } } doA() and doSomethingLongRunning() are still executed even if setState { ... } which got executed before causes our state machine to move to the next state. The takeaway is: the full onEnter { ... } block will be executed once a state has been entered (there is an exception, we will talk about that in FlatMapPolicy section). on <Action> \u00b6 How do we deal with external user input like clicks in FlowRedux? This is what Actions are for. In FlowRedux DSL you can react on Actions by using a on<MyAction>{ ... } block. In our example we want to retry loading if we are in ErrorState and the user clicks on a retry button. Clicking on that button dispatches a RetryLoadingAction to our state machine. Let\u2019s extend our FlowReduxStateMachine to react on such an action if the current state is ErrorState : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( t ) } } } } // let's add a new inState{...} with an on{...} block \uf60e inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> // This block triggers if we are in ErrorState // RetryLoadingAction has been dispatched to this state machine. // In that case we transition to LoadingState which then starts the http // request to load items. setState { LoadingState } } } } } } A on { ... } block gets 3 parameters: action which is the actual instance of the Action that triggered this block and setState and getState which you have also seen in onEnter { ... } block. on { ... } is actually pretty similar to onEnter {...} just with a different \u201ctrigger\u201d (action vs. entering a state). Furthermore, on { ... } has the same characteristics as onEnter { ... } : on<MyAction> { ... } is running asynchronously in a coroutine . You can totally run here long running and expensive calls (like doing an http request). on<MyAction> { ... } doesn\u2019t get canceled when the state machine transitioned to another state original state. See onEnter section for more details. collectWhileInState() \u00b6 This one is useful if you want to collect a Flow only while being exactly in that state. To give a concrete example how this is useful let\u2019s extend our example from above. Let\u2019s say whenever our state machine is in ErrorState we want to retry loading the items after 3 seconds in ErrorState or anytime before the 3 seconds have elapsed if the user clicks the retry button. Furthermore the 3 seconds countdown timer should be displayed in our app: To implement this let\u2019s first extend our ErrorState : data class ErrorState ( val cause : Throwable , val countdown : Int // This value is decreased from 3 then 2 then 1 and represents the countdown value. ) : State () Now let\u2019s add some countdown capabilities to our state machine by using collectWhileInState() : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> setState { LoadingState } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Let\u2019s look at the source code above step by step. Whenever we are in LoadingState and an error occurs while loading the items we go into ErrorState . Nothing new. What is new is that ErrorState contains an additional field countdown which we set on transitioning from LoadingState to ErrorState(countdown = 3) (means 3 seconds left). We extend inState<ErrorState> { ... } block and add a collectWhileInState(timer) . timer is a Flow<Int> that emits a new (incremented) number every second. collectWhileInState(timer) calls .collect {...} on the timer flow and executes the block with the parameters value , getState and setState every time timer emits a new value. In other words: instead of calling timer.collect { ... } you call collectWhileInState(timer) { ... } to collect the Flow\u2019s values as long as the state machine is in that state. But here is the deal: it automatically cancels the timer once the state machine transitioned away from ErrorState into another state. This happens either when the user clicks on the retry button and causes on<RetryLoadingAction> to be dispatched or when 3 seconds have elapsed. To keep track how many seconds are left we decrease ErrorState.countdown field after every second until we reached zero. On zero we call setState { LoadingState } to do the state transition. collectWhileInState(anyFlow) { value, getState, setState -> ... } has 3 parameters: value is the value emitted by the flow, getState to get the current state and setState to do a state transition. In contrast to onEnter and on<Action> block collectWhileInState() block stops the execution once the state machine is not in the original inState<State> anymore. Custom condition for inState \u00b6 We already covered inState<State> that builds upon the recommended best practice that every State in your state machine is expressed us it\u2019s own type in Kotlin. Again, this is a best practice and the recommended way. Sometimes, however, you need a bit more flexibility then just relaying on type. For that use case you can use inState(isInState: (State) -> Boolean) . Example: One could have also modeled the state for our example above as the following: // TO MODEL YOUR STATE LIKE THIS IS NOT BEST PRACTICE! Use sealed class instead. data class State ( val loading : Boolean , // true means loading, false means not loading val items : List < Items >, // empty list if no items loaded yet val error : Throwable ?, // if not null we are in error state val errorCountDown : Int ? // the seconds for the error countdown ) AGAIN, the example shown above is not the recommended way. We strongly recommend to use sealed classes instead to model state as shown at the beginning of this document. We just do this for demo purpose to demonstrate a way how to customize inState . Given the state from above, what we can do now with our DSL is the following: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = State ( loading = true , items = emptyList (), error = null , errorCountDown = null )) { init { spec { inState ( isInState = { state -> state . loading == true } ) { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { State ( loading = false , items = items , error = null , errorCountdown = null ) } } catch ( t : Throwable ) { setState { State ( loading = false , items = emptyList (), error = t , errorCountdown = 3 ) } // Countdown starts with 3 seconds } } } inState ( isInState = { state -> state . error != null } ) { on < RetryLoadingAction > { action , getState , setState -> setState { State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () val countdownTimeLeft = state . errorCountdown !! if ( countdownTimeLeft > 0 ) setState { state . copy ( errorCountdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) // transition to the LoadingState } } } } } } } Instead of inState<State> { ... } we can use another version of inState name that instead of generics take a lambda as parameter that looks like (State) -> Boolean so that. If that lambda returns true it means we are in that state, otherwise not (returning false). The rest still remains the same. You can use onEnter , on<Action> and collectWhileInState the exact way as you already know. collectWhileInAnyState() \u00b6 If for whatever reason you want to trigger a state change out of inState<> , onEnter { ... } , on<Action> or collectWhileInState { ... } by observing a Flow then collectWhileInAnyState is what you are looking for: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> ... } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> ... } collectWhileInState ( timer ) { value , getState , setState -> ... } } val aFlow : Flow < Int > = flowOf ( 1 , 2 , 3 , 4 ) collectWhileInAnyState ( aFlow ) { value , getState , setState -> // Will trigger anytime flow emits a value ... } collectWhileInAnyState ( anotherFlow ) { value , getState , setState -> // Will trigger anytime flow emits a value ... } } } } collectWhileInAnyState() is like collectWhileInState() just that it is not bound to the current state like collectWhileInState() is. collectWhileInAnyState() will stop collecting the passed in Flow only if the CoroutineScope of the whole FlowReduxStateMachine gets canceled. SetState \u00b6 As you probably have already noticed from the sections above setState is a way to make you state machine transition to another state. You can think of SetState as a function that gets the current state as input parameter and returns the new State: fun setState ( currentState : State ) : State { val newState : State = ... // compute new state somehow return newState } Due to some kotlin language restriction SetState is actually a class and not just a function but that doesn\u2019t have to bother you as it is an implementation detail of FlowRedux. You can totally think of it as a function (State) -> State . One important thing you have to know about FlowRedux in general is that FlowRedux is running async. That means that there might be multiple setState { ... } in the queue trying to change the state (but only 1 SetState will be actually executed at the same time). This means that it is possible that on setState { ... } execution the state is actually not in the same state anymore as you would have expected. Per default FlowRedux will check if the state is still the expected one and if it isn\u2019t setState {...} wont run. If you want to override this behavior you can do that by providing an additional parameter runIf and return true if FlowRedux should run setState, otherwise false. setState ( runIf = { currentState -> currentState is FooState }) { currentState -> // executed only if runIf returns true OtherState } For example if you want to force setState to run always you can do the following: setState ( runIf = { true }) { currentState -> OtherState } GetState \u00b6 If you need in any block the current state GetState is your friend. It is actually just a function that you can invoke that returns you the current state of your state machine. FlatMapPolicy \u00b6 Have you ever wondered what would happen if you would execute Action very fast 1 after another? For example: spec { inState < FooState > { on < BarAction > { _ , _ , setState -> delay ( 5000 ) // wait for 5000 seconds setState { OtherState } } } } The example above shows a problem with async. state machines like FlowRedux: If we our state machine is in FooState and a BarAction got triggered, we wait for 5 seconds and then set the state to another state. What if while waiting 5 seconds (i.e. let\u2019s say after 3 seconds of waiting) another BarAction gets triggered. That is possible right? With FlatMapPolicy you can specify what should happen in that case. There are three options to choose from: LATEST : This is the default one. It would cancel any previous execution and just run the latest one. In the example above it would mean while waiting 5 seconds another BarAction gets triggered, the first execution of on<BarAction> block gets stopped and a new on<BarAction> block starts. MERGE : Choosing this causes all the blocks to continue running but there are no guarantees in which order. For example: spec { inState < FooState > { on < BarAction >( flatMapPolicy = FlapMapPolicy . MERGE ) { _ , _ , setState -> delay ( randomInt () ) // wait for some random time setState { OtherState } } } } Let\u2019s assume that we trigger two times BarAction . We use random amount of seconds for waiting. Since we use MERGE on<BarAction> block gets executed 2 times without canceling the previous one (that is the difference to LATEST ). Moreover, MERGE doesn\u2019t make any promise on order of execution of the block (see CONCAT if you need promises on order). So if on<BarAction> gets executed two times it will run in parallel and the the second execution could complete before the first execution (because using a random time of waiting). CONCAT : In contrast to MERGE and LATEST CONCAT will not run on<BarAction> in parallel and will not cancel any previous execution. Instead, CONCAT will preserve the order and execute one block after another. All execution blocks can specify a FlatMapPolicy : on<Action>(flatMapPolicy = FlatMapPolicy.LATEST){... } onEnter(flatMapPolicy = FlatMapPolicy.LATEST) { ... } collectWhileInState(flatMapPolicy = FlatMapPolicy.LATEST) { ... } Best Practice \u00b6 One very important aspect of the DSL is to provide a readable and maintainable way to reason about your state machine. Let\u2019 take a look at our example state machine: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> setState { LoadingState } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Do you notice something? With more blocks we add the state machine itself gets harder to read, understand and maintain. What we are aiming for with the DSL is an overview about what the state machine is supposed to do on a high level that reads like as specification. If you take a look at the example from above, however, you will notice that it isn\u2019t easy to read and get bloated with implementation details. The recommended way \u00b6 We recommend to keep the DSL really short, expressive, readable and maintainable. Therefore instead of having implementation details in your DSL we recommend to use function references instead. Let\u2019s refactor the example above to reflect this idea: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { // // This is the specification of your state machine. Less implementation details, better readability. // init { spec { inState < LoadingState > { onEnter ( :: loadItemsAndMoveToContentOrErrorState ) } inState < ErrorState > { on < RetryLoadingAction > { _ , _ , setState -> // For a single line statement it's ok to keep the block instead of moving to a function reference setState { LoadingState } } collectWhileInState ( timerThatEmitsEverySecond (), :: onSecondElapsedMoveToLoadingStateOrMoveToDecrementCountdown ) } } } // // All the implementation details are in the functions below. // private fun loadItemsAndMoveToContentOrErrorState ( getState : GetState < State >, setState : SetState < State >){ try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } private fun onSecondElapsedMoveToLoadingStateOrMoveToDecrementCountdown ( value : Int , getState : GetState < State >, setState : SetState < State > ){ val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } By using function references you can read the DSL better and can zoom in into implementation details anytime you want to by looking into a function body.","title":"DSL Guide"},{"location":"dsl/#dsl-guide","text":"FlowRedux provides a convenient DSL to describe your state machine. This page introduces you the DSL that you can use. To do that we will stick with a simple example of loading a list of items from a web service. As you read this section and more concepts of the DSL will be introduced we will extend this sample. For now to get started, let\u2019s define the States our state machine has. As said before we loads a list of items from a web service and display that list. While loading the list we show a loading indicator on the screen and if an error occurs we show an error message on the screen with a retry button. This gives us the following states: sealed class State { // Shows a loading indicator on screen object LoadingState : State () // List of items loaded successfully, show it on screen data class ShowContentState ( val items : List < Item >) : State () // Error while loading happened data class ErrorState ( val cause : Throwable ) : State () } If we reached ErrorState we display an error message but also a button a user can click to retry loading the items. This gives us the following Actions : sealed class Action { object RetryLoadingAction : Action () }","title":"DSL Guide"},{"location":"dsl/#initial-state","text":"Every FlowReduxStateMachine needs an initial state. This is in which state the state machine starts. In our example we start with the LoadingState . class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { // will be filled in next section ... } } } Please note the constructor parameter of FlowReduxStateMachine(initialState = ...) . This is how you define the initial state of your state machine. Next, we already see that we need an init {...} block containing a spec { ... } block inside. The spec { ... } block is actually where we write our DSL inside.","title":"Initial State"},{"location":"dsl/#instatestate","text":"The first concept we learn is inState class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { ... } } } } Please note that inState itself doesn\u2019t do anything. All we did so far with inState<LoadingState> is set an entry point. Next let\u2019s discuss what an inState can contain as triggers to actually \u201cdo something\u201d: onEnter : Triggers whenever we enter that state on<Action> : Triggers whenever we are in this state and the specified action is triggered from the outside by calling FlowReduxStateMachine.dispatch(action) . collectWhileInState( flow ) : You can subscribe to any arbitrary Flow while your state machine is in that state. Let\u2019s try to go through them as we build our state machine:","title":"inState&lt;State&gt;"},{"location":"dsl/#onenter","text":"What do we want to do when we enter the LoadingState ? We want to do the http request, right? Let\u2019s do that by extending our example: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( t ) } } } } } } } There are a some new things like onEnter , getState and setState . We will cover getState and setState in dedicated sections. All you have to know about setState for now is that this is the way to set the next state in your state machine. Let\u2019s talk about onEnter : onEnter { ... } is running asynchronously in a coroutine . That means whatever you do inside the onEnter block is not blocking anything else. You can totally run here long running and expensive calls (like doing an http request). onEnter { ... } doesn\u2019t get canceled when the state machine transitioned to another state original state. Example: inState < LoadingState > { onEnter { getState , setState -> setState { ErrorState ( Exception ( \"Fake Exception\" ) } doA () doSomethingLongRunning () } } doA() and doSomethingLongRunning() are still executed even if setState { ... } which got executed before causes our state machine to move to the next state. The takeaway is: the full onEnter { ... } block will be executed once a state has been entered (there is an exception, we will talk about that in FlatMapPolicy section).","title":"onEnter"},{"location":"dsl/#onaction","text":"How do we deal with external user input like clicks in FlowRedux? This is what Actions are for. In FlowRedux DSL you can react on Actions by using a on<MyAction>{ ... } block. In our example we want to retry loading if we are in ErrorState and the user clicks on a retry button. Clicking on that button dispatches a RetryLoadingAction to our state machine. Let\u2019s extend our FlowReduxStateMachine to react on such an action if the current state is ErrorState : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( t ) } } } } // let's add a new inState{...} with an on{...} block \uf60e inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> // This block triggers if we are in ErrorState // RetryLoadingAction has been dispatched to this state machine. // In that case we transition to LoadingState which then starts the http // request to load items. setState { LoadingState } } } } } } A on { ... } block gets 3 parameters: action which is the actual instance of the Action that triggered this block and setState and getState which you have also seen in onEnter { ... } block. on { ... } is actually pretty similar to onEnter {...} just with a different \u201ctrigger\u201d (action vs. entering a state). Furthermore, on { ... } has the same characteristics as onEnter { ... } : on<MyAction> { ... } is running asynchronously in a coroutine . You can totally run here long running and expensive calls (like doing an http request). on<MyAction> { ... } doesn\u2019t get canceled when the state machine transitioned to another state original state. See onEnter section for more details.","title":"on&lt;Action&gt;"},{"location":"dsl/#collectwhileinstate","text":"This one is useful if you want to collect a Flow only while being exactly in that state. To give a concrete example how this is useful let\u2019s extend our example from above. Let\u2019s say whenever our state machine is in ErrorState we want to retry loading the items after 3 seconds in ErrorState or anytime before the 3 seconds have elapsed if the user clicks the retry button. Furthermore the 3 seconds countdown timer should be displayed in our app: To implement this let\u2019s first extend our ErrorState : data class ErrorState ( val cause : Throwable , val countdown : Int // This value is decreased from 3 then 2 then 1 and represents the countdown value. ) : State () Now let\u2019s add some countdown capabilities to our state machine by using collectWhileInState() : class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> setState { LoadingState } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Let\u2019s look at the source code above step by step. Whenever we are in LoadingState and an error occurs while loading the items we go into ErrorState . Nothing new. What is new is that ErrorState contains an additional field countdown which we set on transitioning from LoadingState to ErrorState(countdown = 3) (means 3 seconds left). We extend inState<ErrorState> { ... } block and add a collectWhileInState(timer) . timer is a Flow<Int> that emits a new (incremented) number every second. collectWhileInState(timer) calls .collect {...} on the timer flow and executes the block with the parameters value , getState and setState every time timer emits a new value. In other words: instead of calling timer.collect { ... } you call collectWhileInState(timer) { ... } to collect the Flow\u2019s values as long as the state machine is in that state. But here is the deal: it automatically cancels the timer once the state machine transitioned away from ErrorState into another state. This happens either when the user clicks on the retry button and causes on<RetryLoadingAction> to be dispatched or when 3 seconds have elapsed. To keep track how many seconds are left we decrease ErrorState.countdown field after every second until we reached zero. On zero we call setState { LoadingState } to do the state transition. collectWhileInState(anyFlow) { value, getState, setState -> ... } has 3 parameters: value is the value emitted by the flow, getState to get the current state and setState to do a state transition. In contrast to onEnter and on<Action> block collectWhileInState() block stops the execution once the state machine is not in the original inState<State> anymore.","title":"collectWhileInState()"},{"location":"dsl/#custom-condition-for-instate","text":"We already covered inState<State> that builds upon the recommended best practice that every State in your state machine is expressed us it\u2019s own type in Kotlin. Again, this is a best practice and the recommended way. Sometimes, however, you need a bit more flexibility then just relaying on type. For that use case you can use inState(isInState: (State) -> Boolean) . Example: One could have also modeled the state for our example above as the following: // TO MODEL YOUR STATE LIKE THIS IS NOT BEST PRACTICE! Use sealed class instead. data class State ( val loading : Boolean , // true means loading, false means not loading val items : List < Items >, // empty list if no items loaded yet val error : Throwable ?, // if not null we are in error state val errorCountDown : Int ? // the seconds for the error countdown ) AGAIN, the example shown above is not the recommended way. We strongly recommend to use sealed classes instead to model state as shown at the beginning of this document. We just do this for demo purpose to demonstrate a way how to customize inState . Given the state from above, what we can do now with our DSL is the following: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = State ( loading = true , items = emptyList (), error = null , errorCountDown = null )) { init { spec { inState ( isInState = { state -> state . loading == true } ) { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { State ( loading = false , items = items , error = null , errorCountdown = null ) } } catch ( t : Throwable ) { setState { State ( loading = false , items = emptyList (), error = t , errorCountdown = 3 ) } // Countdown starts with 3 seconds } } } inState ( isInState = { state -> state . error != null } ) { on < RetryLoadingAction > { action , getState , setState -> setState { State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () val countdownTimeLeft = state . errorCountdown !! if ( countdownTimeLeft > 0 ) setState { state . copy ( errorCountdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { State ( loading = true , items = emptyList (), error = null , errorCountdown = null ) // transition to the LoadingState } } } } } } } Instead of inState<State> { ... } we can use another version of inState name that instead of generics take a lambda as parameter that looks like (State) -> Boolean so that. If that lambda returns true it means we are in that state, otherwise not (returning false). The rest still remains the same. You can use onEnter , on<Action> and collectWhileInState the exact way as you already know.","title":"Custom condition for inState"},{"location":"dsl/#collectwhileinanystate","text":"If for whatever reason you want to trigger a state change out of inState<> , onEnter { ... } , on<Action> or collectWhileInState { ... } by observing a Flow then collectWhileInAnyState is what you are looking for: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> ... } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> ... } collectWhileInState ( timer ) { value , getState , setState -> ... } } val aFlow : Flow < Int > = flowOf ( 1 , 2 , 3 , 4 ) collectWhileInAnyState ( aFlow ) { value , getState , setState -> // Will trigger anytime flow emits a value ... } collectWhileInAnyState ( anotherFlow ) { value , getState , setState -> // Will trigger anytime flow emits a value ... } } } } collectWhileInAnyState() is like collectWhileInState() just that it is not bound to the current state like collectWhileInState() is. collectWhileInAnyState() will stop collecting the passed in Flow only if the CoroutineScope of the whole FlowReduxStateMachine gets canceled.","title":"collectWhileInAnyState()"},{"location":"dsl/#setstate","text":"As you probably have already noticed from the sections above setState is a way to make you state machine transition to another state. You can think of SetState as a function that gets the current state as input parameter and returns the new State: fun setState ( currentState : State ) : State { val newState : State = ... // compute new state somehow return newState } Due to some kotlin language restriction SetState is actually a class and not just a function but that doesn\u2019t have to bother you as it is an implementation detail of FlowRedux. You can totally think of it as a function (State) -> State . One important thing you have to know about FlowRedux in general is that FlowRedux is running async. That means that there might be multiple setState { ... } in the queue trying to change the state (but only 1 SetState will be actually executed at the same time). This means that it is possible that on setState { ... } execution the state is actually not in the same state anymore as you would have expected. Per default FlowRedux will check if the state is still the expected one and if it isn\u2019t setState {...} wont run. If you want to override this behavior you can do that by providing an additional parameter runIf and return true if FlowRedux should run setState, otherwise false. setState ( runIf = { currentState -> currentState is FooState }) { currentState -> // executed only if runIf returns true OtherState } For example if you want to force setState to run always you can do the following: setState ( runIf = { true }) { currentState -> OtherState }","title":"SetState"},{"location":"dsl/#getstate","text":"If you need in any block the current state GetState is your friend. It is actually just a function that you can invoke that returns you the current state of your state machine.","title":"GetState"},{"location":"dsl/#flatmappolicy","text":"Have you ever wondered what would happen if you would execute Action very fast 1 after another? For example: spec { inState < FooState > { on < BarAction > { _ , _ , setState -> delay ( 5000 ) // wait for 5000 seconds setState { OtherState } } } } The example above shows a problem with async. state machines like FlowRedux: If we our state machine is in FooState and a BarAction got triggered, we wait for 5 seconds and then set the state to another state. What if while waiting 5 seconds (i.e. let\u2019s say after 3 seconds of waiting) another BarAction gets triggered. That is possible right? With FlatMapPolicy you can specify what should happen in that case. There are three options to choose from: LATEST : This is the default one. It would cancel any previous execution and just run the latest one. In the example above it would mean while waiting 5 seconds another BarAction gets triggered, the first execution of on<BarAction> block gets stopped and a new on<BarAction> block starts. MERGE : Choosing this causes all the blocks to continue running but there are no guarantees in which order. For example: spec { inState < FooState > { on < BarAction >( flatMapPolicy = FlapMapPolicy . MERGE ) { _ , _ , setState -> delay ( randomInt () ) // wait for some random time setState { OtherState } } } } Let\u2019s assume that we trigger two times BarAction . We use random amount of seconds for waiting. Since we use MERGE on<BarAction> block gets executed 2 times without canceling the previous one (that is the difference to LATEST ). Moreover, MERGE doesn\u2019t make any promise on order of execution of the block (see CONCAT if you need promises on order). So if on<BarAction> gets executed two times it will run in parallel and the the second execution could complete before the first execution (because using a random time of waiting). CONCAT : In contrast to MERGE and LATEST CONCAT will not run on<BarAction> in parallel and will not cancel any previous execution. Instead, CONCAT will preserve the order and execute one block after another. All execution blocks can specify a FlatMapPolicy : on<Action>(flatMapPolicy = FlatMapPolicy.LATEST){... } onEnter(flatMapPolicy = FlatMapPolicy.LATEST) { ... } collectWhileInState(flatMapPolicy = FlatMapPolicy.LATEST) { ... }","title":"FlatMapPolicy"},{"location":"dsl/#best-practice","text":"One very important aspect of the DSL is to provide a readable and maintainable way to reason about your state machine. Let\u2019 take a look at our example state machine: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { init { spec { inState < LoadingState > { onEnter { getState , setState -> // we entered the LoadingState, so let's do the http request try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } } inState < ErrorState > { on < RetryLoadingAction > { action , getState , setState -> setState { LoadingState } } val timer : Flow < Int > = timerThatEmitsEverySecond () collectWhileInState ( timer ) { value , getState , setState -> // This block triggers every time the timer emits // which happens every second val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } } } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } Do you notice something? With more blocks we add the state machine itself gets harder to read, understand and maintain. What we are aiming for with the DSL is an overview about what the state machine is supposed to do on a high level that reads like as specification. If you take a look at the example from above, however, you will notice that it isn\u2019t easy to read and get bloated with implementation details.","title":"Best Practice"},{"location":"dsl/#the-recommended-way","text":"We recommend to keep the DSL really short, expressive, readable and maintainable. Therefore instead of having implementation details in your DSL we recommend to use function references instead. Let\u2019s refactor the example above to reflect this idea: class MyStateMachine ( private val httpClient : HttpClient ) : FlowReduxStateMachine < State , Action >( initialState = LoadingState ) { // // This is the specification of your state machine. Less implementation details, better readability. // init { spec { inState < LoadingState > { onEnter ( :: loadItemsAndMoveToContentOrErrorState ) } inState < ErrorState > { on < RetryLoadingAction > { _ , _ , setState -> // For a single line statement it's ok to keep the block instead of moving to a function reference setState { LoadingState } } collectWhileInState ( timerThatEmitsEverySecond (), :: onSecondElapsedMoveToLoadingStateOrMoveToDecrementCountdown ) } } } // // All the implementation details are in the functions below. // private fun loadItemsAndMoveToContentOrErrorState ( getState : GetState < State >, setState : SetState < State >){ try { val items = httpClient . loadItems () setState { ShowContentState ( items ) } } catch ( t : Throwable ) { setState { ErrorState ( cause = t , countdown = 3 ) } // Countdown starts with 3 seconds } } private fun onSecondElapsedMoveToLoadingStateOrMoveToDecrementCountdown ( value : Int , getState : GetState < State >, setState : SetState < State > ){ val state = getState () if ( state is ErrorState ) { val countdownTimeLeft = state . countdown if ( countdownTimeLeft > 0 ) setState { state . copy ( countdown = countdownTimeLeft - 1 ) } // decrease the countdown by 1 second else setState { LoadingState } // transition to the LoadingState } } private fun timerThatEmitsEverySecond () : Flow < Int > { var timeElapsed = 0 while ( isActive ) { // is Flow still active? delay ( 1000 ) // wait 1 second timeElapsed ++ emit ( timeElapsed ) // Flow Emits value } } } By using function references you can read the DSL better and can zoom in into implementation details anytime you want to by looking into a function body.","title":"The recommended way"},{"location":"flow_vs_FlowReduxStateMachine/","text":"FlowReduxStateMachine vs .reduxStore() \u00b6 The DSL provided by FlowRedux can be use int two ways: Extending from FlowReduxStateMachine Use .reduxStore() which is a custom operator on Kotlin\u2019s Flow type. FlowReduxStateMachine \u00b6 This is probably the easiest way to get started writing a State Machine with FlowRedux DSL. class MyStateMachine : FlowReduxStateMachine < State , Action >( InitialState ){ init { spec { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } } } See DSL section for more information how to use the DSL. The advantage of extending from FlowReduxStateMachine is that you get a ready a base template where you just have to fill in the DSL part inside the spec { ... } block. By extending from FlowReduxStateMachine your StateMachine inherits a dispatch(action : Action) method to dispatch Actions to your state machine and a val state: Flow<State> to observe your state machine\u2019s state. Whenever the state changes, the latest State will be emitted to this Flow . .reduxStore() \u00b6 If you want to work with Flow type directly FlowRedux provides you a custom operator called .reduxStore() . It is a custom operator like any other Flow operator like Flow.map { ... } . The idea is that the upstream Flow brings the actions to your FlowReduxStore like this: sealed class Action { object Action1 : MyAction () object Action2 : MyAction () } val actionFlow : Flow < Action > = flowOf { emit ( Action1 ) delay ( 2000 ) emit ( Action2 ) } val stateFlow : Flow < State > = actionFlow // actionFlow is the input actions to the state machine . reduxStore < Action , State >( IntialState ) { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } stateFlow . collect { state -> updateUi ( state ) }","title":"FlowReduxStateMachine vs .reduxStore()"},{"location":"flow_vs_FlowReduxStateMachine/#flowreduxstatemachine-vs-reduxstore","text":"The DSL provided by FlowRedux can be use int two ways: Extending from FlowReduxStateMachine Use .reduxStore() which is a custom operator on Kotlin\u2019s Flow type.","title":"FlowReduxStateMachine vs .reduxStore()"},{"location":"flow_vs_FlowReduxStateMachine/#flowreduxstatemachine","text":"This is probably the easiest way to get started writing a State Machine with FlowRedux DSL. class MyStateMachine : FlowReduxStateMachine < State , Action >( InitialState ){ init { spec { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } } } See DSL section for more information how to use the DSL. The advantage of extending from FlowReduxStateMachine is that you get a ready a base template where you just have to fill in the DSL part inside the spec { ... } block. By extending from FlowReduxStateMachine your StateMachine inherits a dispatch(action : Action) method to dispatch Actions to your state machine and a val state: Flow<State> to observe your state machine\u2019s state. Whenever the state changes, the latest State will be emitted to this Flow .","title":"FlowReduxStateMachine"},{"location":"flow_vs_FlowReduxStateMachine/#reduxstore","text":"If you want to work with Flow type directly FlowRedux provides you a custom operator called .reduxStore() . It is a custom operator like any other Flow operator like Flow.map { ... } . The idea is that the upstream Flow brings the actions to your FlowReduxStore like this: sealed class Action { object Action1 : MyAction () object Action2 : MyAction () } val actionFlow : Flow < Action > = flowOf { emit ( Action1 ) delay ( 2000 ) emit ( Action2 ) } val stateFlow : Flow < State > = actionFlow // actionFlow is the input actions to the state machine . reduxStore < Action , State >( IntialState ) { // Your DSL goes inside this spec block. // Example: inState < State1 > { onAction < Action1 > { ... } } } stateFlow . collect { state -> updateUi ( state ) }","title":".reduxStore()"},{"location":"multiplatform/","text":"Multiplatform \u00b6 FlowRedux is supported on: JVM / Android iOS x64 iOS ARM64 + ARM 32 watchOS x86 watchOS ARM64 + ARM 32 tvOS x86 tvOS ARM64 + ARM 32 We do plan to add support for JavaScript but it\u2019s not available yet.","title":"Multiplatform"},{"location":"multiplatform/#multiplatform","text":"FlowRedux is supported on: JVM / Android iOS x64 iOS ARM64 + ARM 32 watchOS x86 watchOS ARM64 + ARM 32 tvOS x86 tvOS ARM64 + ARM 32 We do plan to add support for JavaScript but it\u2019s not available yet.","title":"Multiplatform"},{"location":"Javadoc/dsl/","text":"dsl Packages \u00b6 Name Summary (jvm) com.freeletics.flowredux.dsl com.freeletics.flowredux.dsl.flow Index \u00b6 All Types","title":"Index"},{"location":"Javadoc/dsl/#packages","text":"Name Summary (jvm) com.freeletics.flowredux.dsl com.freeletics.flowredux.dsl.flow","title":"Packages"},{"location":"Javadoc/dsl/#index","text":"All Types","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl.flow/","text":"dsl / com.freeletics.flowredux.dsl.flow Package com.freeletics.flowredux.dsl.flow \u00b6","title":"Com.freeletics.flowredux.dsl.flow"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl.flow/#package-comfreeleticsflowreduxdslflow","text":"","title":"Package com.freeletics.flowredux.dsl.flow"},{"location":"Javadoc/dsl/alltypes/","text":"All Types \u00b6 Name Summary (jvm) com.freeletics.flowredux.dsl.FlatMapPolicy \u00b6 Defines which flatMap behavior should be applied whenever a new values is emitted |(jvm) (extensions in package com.freeletics.flowredux.dsl) kotlinx.coroutines.flow.Flow \u00b6 |(jvm) com.freeletics.flowredux.dsl.FlowReduxStateMachine \u00b6 |(jvm) com.freeletics.flowredux.dsl.FlowReduxStoreBuilder \u00b6 |(jvm) com.freeletics.flowredux.dsl.InStateBuilderBlock \u00b6 |(jvm) com.freeletics.flowredux.dsl.InStateObserverBlock \u00b6 |(jvm) com.freeletics.flowredux.dsl.InStateOnEnterBlock \u00b6 |(jvm) com.freeletics.flowredux.dsl.InStateSideEffectBuilder \u00b6 It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. |(jvm) com.freeletics.flowredux.dsl.OnActionBlock \u00b6 |(jvm) com.freeletics.flowredux.dsl.OnActionInStateSideEffectBuilder \u00b6 |(jvm) com.freeletics.flowredux.dsl.OnEnterInStateSideEffectBuilder \u00b6 A builder that generates a SideEffect that triggers every time the state machine enters a certain state. |(jvm) com.freeletics.flowredux.dsl.SetState \u00b6 SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: |(jvm) com.freeletics.flowredux.dsl.StoreWideBuilderBlock \u00b6 It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. |(jvm) com.freeletics.flowredux.dsl.StoreWideCollectorBlock \u00b6","title":"Index"},{"location":"Javadoc/dsl/alltypes/#all-types","text":"Name Summary (jvm)","title":"All Types"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslflatmappolicy","text":"Defines which flatMap behavior should be applied whenever a new values is emitted |(jvm) (extensions in package com.freeletics.flowredux.dsl)","title":"com.freeletics.flowredux.dsl.FlatMapPolicy"},{"location":"Javadoc/dsl/alltypes/#kotlinxcoroutinesflowflow","text":"|(jvm)","title":"kotlinx.coroutines.flow.Flow"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslflowreduxstatemachine","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.FlowReduxStateMachine"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslflowreduxstorebuilder","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.FlowReduxStoreBuilder"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslinstatebuilderblock","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.InStateBuilderBlock"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslinstateobserverblock","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.InStateObserverBlock"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslinstateonenterblock","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.InStateOnEnterBlock"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslinstatesideeffectbuilder","text":"It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. |(jvm)","title":"com.freeletics.flowredux.dsl.InStateSideEffectBuilder"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslonactionblock","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.OnActionBlock"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslonactioninstatesideeffectbuilder","text":"|(jvm)","title":"com.freeletics.flowredux.dsl.OnActionInStateSideEffectBuilder"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslonenterinstatesideeffectbuilder","text":"A builder that generates a SideEffect that triggers every time the state machine enters a certain state. |(jvm)","title":"com.freeletics.flowredux.dsl.OnEnterInStateSideEffectBuilder"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslsetstate","text":"SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: |(jvm)","title":"com.freeletics.flowredux.dsl.SetState"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslstorewidebuilderblock","text":"It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. |(jvm)","title":"com.freeletics.flowredux.dsl.StoreWideBuilderBlock"},{"location":"Javadoc/dsl/alltypes/#comfreeleticsflowreduxdslstorewidecollectorblock","text":"","title":"com.freeletics.flowredux.dsl.StoreWideCollectorBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/","text":"dsl / com.freeletics.flowredux.dsl Package com.freeletics.flowredux.dsl \u00b6 Types \u00b6 Name Summary (jvm) FlatMapPolicy Defines which flatMap behavior should be applied whenever a new values is emitted enum class FlatMapPolicy (jvm) FlowReduxStateMachine abstract class FlowReduxStateMachine<S : Any , A : Any > (jvm) FlowReduxStoreBuilder class FlowReduxStoreBuilder<S : Any , A : Any > (jvm) InStateBuilderBlock class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A> (jvm) InStateObserverBlock typealias InStateObserverBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) InStateOnEnterBlock typealias InStateOnEnterBlock<S> = suspend (getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) InStateSideEffectBuilder It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. abstract class InStateSideEffectBuilder<S, A> (jvm) OnActionBlock typealias OnActionBlock<S, A> = suspend (action: A, getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) OnActionInStateSideEffectBuilder class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) OnEnterInStateSideEffectBuilder A builder that generates a SideEffect that triggers every time the state machine enters a certain state. class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) SetState SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: abstract class SetState<S> (jvm) StoreWideBuilderBlock It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. abstract class StoreWideBuilderBlock<S, A> (jvm) StoreWideCollectorBlock typealias StoreWideCollectorBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit Extensions for External Classes \u00b6 Name Summary (jvm) kotlinx.coroutines.flow.Flow","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/#package-comfreeleticsflowreduxdsl","text":"","title":"Package com.freeletics.flowredux.dsl"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/#types","text":"Name Summary (jvm) FlatMapPolicy Defines which flatMap behavior should be applied whenever a new values is emitted enum class FlatMapPolicy (jvm) FlowReduxStateMachine abstract class FlowReduxStateMachine<S : Any , A : Any > (jvm) FlowReduxStoreBuilder class FlowReduxStoreBuilder<S : Any , A : Any > (jvm) InStateBuilderBlock class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A> (jvm) InStateObserverBlock typealias InStateObserverBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) InStateOnEnterBlock typealias InStateOnEnterBlock<S> = suspend (getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) InStateSideEffectBuilder It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. abstract class InStateSideEffectBuilder<S, A> (jvm) OnActionBlock typealias OnActionBlock<S, A> = suspend (action: A, getState: GetState<S>, setState: SetState <S>) -> Unit (jvm) OnActionInStateSideEffectBuilder class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) OnEnterInStateSideEffectBuilder A builder that generates a SideEffect that triggers every time the state machine enters a certain state. class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) SetState SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: abstract class SetState<S> (jvm) StoreWideBuilderBlock It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. abstract class StoreWideBuilderBlock<S, A> (jvm) StoreWideCollectorBlock typealias StoreWideCollectorBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit","title":"Types"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/#extensions-for-external-classes","text":"Name Summary (jvm) kotlinx.coroutines.flow.Flow","title":"Extensions for External Classes"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-observer-block/","text":"dsl / com.freeletics.flowredux.dsl / InStateObserverBlock InStateObserverBlock \u00b6 (jvm) typealias InStateObserverBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit","title":" in state observer block"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-observer-block/#instateobserverblock","text":"(jvm) typealias InStateObserverBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit","title":"InStateObserverBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-on-enter-block/","text":"dsl / com.freeletics.flowredux.dsl / InStateOnEnterBlock InStateOnEnterBlock \u00b6 (jvm) typealias InStateOnEnterBlock<S> = suspend (getState: GetState<S>, setState: SetState <S>) -> Unit","title":" in state on enter block"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-on-enter-block/#instateonenterblock","text":"(jvm) typealias InStateOnEnterBlock<S> = suspend (getState: GetState<S>, setState: SetState <S>) -> Unit","title":"InStateOnEnterBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-side-effect-builder/","text":"dsl / com.freeletics.flowredux.dsl / InStateSideEffectBuilder InStateSideEffectBuilder \u00b6 (jvm) abstract class InStateSideEffectBuilder<S, A> It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. Inheritors \u00b6 Name Summary (jvm) OnActionInStateSideEffectBuilder class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) OnEnterInStateSideEffectBuilder A builder that generates a SideEffect that triggers every time the state machine enters a certain state. class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A>","title":" in state side effect builder"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-side-effect-builder/#instatesideeffectbuilder","text":"(jvm) abstract class InStateSideEffectBuilder<S, A> It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface.","title":"InStateSideEffectBuilder"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-side-effect-builder/#inheritors","text":"Name Summary (jvm) OnActionInStateSideEffectBuilder class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> (jvm) OnEnterInStateSideEffectBuilder A builder that generates a SideEffect that triggers every time the state machine enters a certain state. class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A>","title":"Inheritors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-block/","text":"dsl / com.freeletics.flowredux.dsl / OnActionBlock OnActionBlock \u00b6 (jvm) typealias OnActionBlock<S, A> = suspend (action: A, getState: GetState<S>, setState: SetState <S>) -> Unit","title":" on action block"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-block/#onactionblock","text":"(jvm) typealias OnActionBlock<S, A> = suspend (action: A, getState: GetState<S>, setState: SetState <S>) -> Unit","title":"OnActionBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/","text":"dsl / com.freeletics.flowredux.dsl / StoreWideBuilderBlock StoreWideBuilderBlock \u00b6 (jvm) abstract class StoreWideBuilderBlock<S, A> It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. It\u2019s also not a sealed class because no need for it (no need to enumerate subclasses as we only care about the abstract functions this class exposes). Also sealed class would mean to move all subclasses into the same File. That is not that nice as it all subclasses are implementation detail heavy. There is no need to have a hundreds of lines of code in one file just to have sealed classes. Inheritors \u00b6 Name Summary (jvm) InStateBuilderBlock class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A>","title":" store wide builder block"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/#storewidebuilderblock","text":"(jvm) abstract class StoreWideBuilderBlock<S, A> It\u2019s just not an Interface to not expose internal class Action to the public. Thus it\u2019s an internal abstract class but you can think of it as an internal interface. It\u2019s also not a sealed class because no need for it (no need to enumerate subclasses as we only care about the abstract functions this class exposes). Also sealed class would mean to move all subclasses into the same File. That is not that nice as it all subclasses are implementation detail heavy. There is no need to have a hundreds of lines of code in one file just to have sealed classes.","title":"StoreWideBuilderBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-store-wide-builder-block/#inheritors","text":"Name Summary (jvm) InStateBuilderBlock class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A>","title":"Inheritors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-store-wide-collector-block/","text":"dsl / com.freeletics.flowredux.dsl / StoreWideCollectorBlock StoreWideCollectorBlock \u00b6 (jvm) typealias StoreWideCollectorBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit","title":" store wide collector block"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-store-wide-collector-block/#storewidecollectorblock","text":"(jvm) typealias StoreWideCollectorBlock<T, S> = suspend (value: T, getState: GetState<S>, setState: SetState <S>) -> Unit","title":"StoreWideCollectorBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/","text":"dsl / com.freeletics.flowredux.dsl / FlatMapPolicy FlatMapPolicy \u00b6 (jvm) enum class FlatMapPolicy Defines which flatMap behavior should be applied whenever a new values is emitted Enum Values \u00b6 Name Summary (jvm) LATEST uses flatMapLatest (jvm) MERGE Uses flatMapMerge (jvm) CONCAT Uses flatMapConcat","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/#flatmappolicy","text":"(jvm) enum class FlatMapPolicy Defines which flatMap behavior should be applied whenever a new values is emitted","title":"FlatMapPolicy"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/#enum-values","text":"Name Summary (jvm) LATEST uses flatMapLatest (jvm) MERGE Uses flatMapMerge (jvm) CONCAT Uses flatMapConcat","title":"Enum Values"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/","text":"dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / CONCAT CONCAT \u00b6 (jvm) CONCAT Uses flatMapConcat","title":" c o n c a t"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-c-o-n-c-a-t/#concat","text":"(jvm) CONCAT Uses flatMapConcat","title":"CONCAT"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/","text":"dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / LATEST LATEST \u00b6 (jvm) LATEST uses flatMapLatest","title":" l a t e s t"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-l-a-t-e-s-t/#latest","text":"(jvm) LATEST uses flatMapLatest","title":"LATEST"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/","text":"dsl / com.freeletics.flowredux.dsl / FlatMapPolicy / MERGE MERGE \u00b6 (jvm) MERGE Uses flatMapMerge","title":" m e r g e"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flat-map-policy/-m-e-r-g-e/#merge","text":"(jvm) MERGE Uses flatMapMerge","title":"MERGE"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine FlowReduxStateMachine \u00b6 (jvm) abstract class FlowReduxStateMachine<S : Any , A : Any > Constructors \u00b6 Name Summary (jvm) <init> FlowReduxStateMachine(initialStateSupplier: () -> S) FlowReduxStateMachine(initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialStateSupplier: () -> S) Properties \u00b6 Name Summary (jvm) state val state: Flow<S> Functions \u00b6 Name Summary (jvm) dispatch suspend fun dispatch(action: A): Unit (jvm) spec fun spec(specBlock: FlowReduxStoreBuilder <S, A>.() -> Unit ): Unit","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#flowreduxstatemachine","text":"(jvm) abstract class FlowReduxStateMachine<S : Any , A : Any >","title":"FlowReduxStateMachine"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#constructors","text":"Name Summary (jvm) <init> FlowReduxStateMachine(initialStateSupplier: () -> S) FlowReduxStateMachine(initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialStateSupplier: () -> S)","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#properties","text":"Name Summary (jvm) state val state: Flow<S>","title":"Properties"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/#functions","text":"Name Summary (jvm) dispatch suspend fun dispatch(action: A): Unit (jvm) spec fun spec(specBlock: FlowReduxStoreBuilder <S, A>.() -> Unit ): Unit","title":"Functions"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/-init-/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / <init> <init> \u00b6 (jvm) FlowReduxStateMachine(initialStateSupplier: () -> S) FlowReduxStateMachine(initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialStateSupplier: () -> S)","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/-init-/#init","text":"(jvm) FlowReduxStateMachine(initialStateSupplier: () -> S) FlowReduxStateMachine(initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialState: S) FlowReduxStateMachine(logger: FlowReduxLogger?, initialStateSupplier: () -> S)","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/dispatch/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / dispatch dispatch \u00b6 (jvm) suspend fun dispatch(action: A): Unit","title":"Dispatch"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/dispatch/#dispatch","text":"(jvm) suspend fun dispatch(action: A): Unit","title":"dispatch"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/spec/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / spec spec \u00b6 (jvm) protected fun spec(specBlock: FlowReduxStoreBuilder <S, A>.() -> Unit ): Unit","title":"Spec"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/spec/#spec","text":"(jvm) protected fun spec(specBlock: FlowReduxStoreBuilder <S, A>.() -> Unit ): Unit","title":"spec"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/state/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStateMachine / state state \u00b6 (jvm) val state: Flow<S>","title":"State"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-state-machine/state/#state","text":"(jvm) val state: Flow<S>","title":"state"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder FlowReduxStoreBuilder \u00b6 (jvm) class FlowReduxStoreBuilder<S : Any , A : Any > Constructors \u00b6 Name Summary (jvm) <init> FlowReduxStoreBuilder() Properties \u00b6 Name Summary (jvm) builderBlocks val builderBlocks: ArrayList < StoreWideBuilderBlock <S, A>> Functions \u00b6 Name Summary (jvm) collectWhileInAnyState Define some global observer to be able to set the state directly from a flow that you observe. A common use case would be to observe a database fun <T> collectWhileInAnyState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: StoreWideCollectorBlock <T, S>): Unit (jvm) inState Define what happens if the store is in a certain state. fun <SubState : S> inState(block: InStateBuilderBlock <S, A>.() -> Unit ): Unit fun inState(isInState: (S) -> Boolean , block: InStateBuilderBlock <S, A>.() -> Unit ): Unit","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#flowreduxstorebuilder","text":"(jvm) class FlowReduxStoreBuilder<S : Any , A : Any >","title":"FlowReduxStoreBuilder"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#constructors","text":"Name Summary (jvm) <init> FlowReduxStoreBuilder()","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#properties","text":"Name Summary (jvm) builderBlocks val builderBlocks: ArrayList < StoreWideBuilderBlock <S, A>>","title":"Properties"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/#functions","text":"Name Summary (jvm) collectWhileInAnyState Define some global observer to be able to set the state directly from a flow that you observe. A common use case would be to observe a database fun <T> collectWhileInAnyState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: StoreWideCollectorBlock <T, S>): Unit (jvm) inState Define what happens if the store is in a certain state. fun <SubState : S> inState(block: InStateBuilderBlock <S, A>.() -> Unit ): Unit fun inState(isInState: (S) -> Boolean , block: InStateBuilderBlock <S, A>.() -> Unit ): Unit","title":"Functions"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/-init-/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / <init> <init> \u00b6 (jvm) FlowReduxStoreBuilder()","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/-init-/#init","text":"(jvm) FlowReduxStoreBuilder()","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/builder-blocks/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / builderBlocks builderBlocks \u00b6 (jvm) val builderBlocks: ArrayList < StoreWideBuilderBlock <S, A>>","title":"Builder blocks"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/builder-blocks/#builderblocks","text":"(jvm) val builderBlocks: ArrayList < StoreWideBuilderBlock <S, A>>","title":"builderBlocks"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/collect-while-in-any-state/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / collectWhileInAnyState collectWhileInAnyState \u00b6 (jvm) fun <T> collectWhileInAnyState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: StoreWideCollectorBlock <T, S>): Unit Define some global observer to be able to set the state directly from a flow that you observe. A common use case would be to observe a database","title":"Collect while in any state"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/collect-while-in-any-state/#collectwhileinanystate","text":"(jvm) fun <T> collectWhileInAnyState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: StoreWideCollectorBlock <T, S>): Unit Define some global observer to be able to set the state directly from a flow that you observe. A common use case would be to observe a database","title":"collectWhileInAnyState"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state/","text":"dsl / com.freeletics.flowredux.dsl / FlowReduxStoreBuilder / inState inState \u00b6 (jvm) inline fun <reified SubState : S> inState(noinline block: InStateBuilderBlock <S, A>.() -> Unit ): Unit fun inState(isInState: (S) -> Boolean , block: InStateBuilderBlock <S, A>.() -> Unit ): Unit Define what happens if the store is in a certain state.","title":"In state"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-flow-redux-store-builder/in-state/#instate","text":"(jvm) inline fun <reified SubState : S> inState(noinline block: InStateBuilderBlock <S, A>.() -> Unit ): Unit fun inState(isInState: (S) -> Boolean , block: InStateBuilderBlock <S, A>.() -> Unit ): Unit Define what happens if the store is in a certain state.","title":"inState"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock InStateBuilderBlock \u00b6 (jvm) class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A> Constructors \u00b6 Name Summary (jvm) <init> InStateBuilderBlock(_isInState: (S) -> Boolean ) Properties \u00b6 Name Summary (jvm) _inStateSideEffectBuilders val _inStateSideEffectBuilders: ArrayList < InStateSideEffectBuilder <S, A>> (jvm) _isInState For private usage only val _isInState: (S) -> Boolean Functions \u00b6 Name Summary (jvm) collectWhileInState fun <T> collectWhileInState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: InStateObserverBlock <T, S>): Unit (jvm) on fun <SubAction : A> on(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: OnActionBlock <S, SubAction>): Unit (jvm) onEnter Triggers every time the state machine enters this state. fun onEnter(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: InStateOnEnterBlock <S>): Unit","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#instatebuilderblock","text":"(jvm) class InStateBuilderBlock<S : Any , A : Any > : StoreWideBuilderBlock <S, A>","title":"InStateBuilderBlock"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#constructors","text":"Name Summary (jvm) <init> InStateBuilderBlock(_isInState: (S) -> Boolean )","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#properties","text":"Name Summary (jvm) _inStateSideEffectBuilders val _inStateSideEffectBuilders: ArrayList < InStateSideEffectBuilder <S, A>> (jvm) _isInState For private usage only val _isInState: (S) -> Boolean","title":"Properties"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/#functions","text":"Name Summary (jvm) collectWhileInState fun <T> collectWhileInState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: InStateObserverBlock <T, S>): Unit (jvm) on fun <SubAction : A> on(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: OnActionBlock <S, SubAction>): Unit (jvm) onEnter Triggers every time the state machine enters this state. fun onEnter(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: InStateOnEnterBlock <S>): Unit","title":"Functions"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/-init-/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / <init> <init> \u00b6 (jvm) InStateBuilderBlock(_isInState: (S) -> Boolean )","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/-init-/#init","text":"(jvm) InStateBuilderBlock(_isInState: (S) -> Boolean )","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_in-state-side-effect-builders/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / _inStateSideEffectBuilders _inStateSideEffectBuilders \u00b6 (jvm) val _inStateSideEffectBuilders: ArrayList < InStateSideEffectBuilder <S, A>>","title":" in state side effect builders"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_in-state-side-effect-builders/#_instatesideeffectbuilders","text":"(jvm) val _inStateSideEffectBuilders: ArrayList < InStateSideEffectBuilder <S, A>>","title":"_inStateSideEffectBuilders"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_is-in-state/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / _isInState _isInState \u00b6 (jvm) val _isInState: (S) -> Boolean For private usage only","title":" is in state"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/_is-in-state/#_isinstate","text":"(jvm) val _isInState: (S) -> Boolean For private usage only","title":"_isInState"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/collect-while-in-state/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / collectWhileInState collectWhileInState \u00b6 (jvm) fun <T> collectWhileInState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: InStateObserverBlock <T, S>): Unit","title":"Collect while in state"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/collect-while-in-state/#collectwhileinstate","text":"(jvm) fun <T> collectWhileInState(flow: Flow<T>, flatMapPolicy: FlatMapPolicy = FlatMapPolicy.CONCAT, block: InStateObserverBlock <T, S>): Unit","title":"collectWhileInState"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on-enter/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / onEnter onEnter \u00b6 (jvm) fun onEnter(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: InStateOnEnterBlock <S>): Unit Triggers every time the state machine enters this state. This does not cancel any ongoing block when the state changes. TODO add a sample","title":"On enter"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on-enter/#onenter","text":"(jvm) fun onEnter(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, block: InStateOnEnterBlock <S>): Unit Triggers every time the state machine enters this state. This does not cancel any ongoing block when the state changes. TODO add a sample","title":"onEnter"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on/","text":"dsl / com.freeletics.flowredux.dsl / InStateBuilderBlock / on on \u00b6 (jvm) inline fun <reified SubAction : A> on(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, noinline block: OnActionBlock <S, SubAction>): Unit","title":"On"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-in-state-builder-block/on/#on","text":"(jvm) inline fun <reified SubAction : A> on(flatMapPolicy: FlatMapPolicy = FlatMapPolicy.LATEST, noinline block: OnActionBlock <S, SubAction>): Unit","title":"on"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-in-state-side-effect-builder/","text":"dsl / com.freeletics.flowredux.dsl / OnActionInStateSideEffectBuilder OnActionInStateSideEffectBuilder \u00b6 (jvm) class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> Constructors \u00b6 Name Summary (jvm) <init> OnActionInStateSideEffectBuilder(isInState: (S) -> Boolean , subActionClass: KClass <out A>, flatMapPolicy: FlatMapPolicy , onActionBlock: OnActionBlock <S, A>)","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-in-state-side-effect-builder/#onactioninstatesideeffectbuilder","text":"(jvm) class OnActionInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A>","title":"OnActionInStateSideEffectBuilder"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-in-state-side-effect-builder/#constructors","text":"Name Summary (jvm) <init> OnActionInStateSideEffectBuilder(isInState: (S) -> Boolean , subActionClass: KClass <out A>, flatMapPolicy: FlatMapPolicy , onActionBlock: OnActionBlock <S, A>)","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-in-state-side-effect-builder/-init-/","text":"dsl / com.freeletics.flowredux.dsl / OnActionInStateSideEffectBuilder / <init> <init> \u00b6 (jvm) OnActionInStateSideEffectBuilder(isInState: (S) -> Boolean , subActionClass: KClass <out A>, flatMapPolicy: FlatMapPolicy , onActionBlock: OnActionBlock <S, A>)","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-action-in-state-side-effect-builder/-init-/#init","text":"(jvm) OnActionInStateSideEffectBuilder(isInState: (S) -> Boolean , subActionClass: KClass <out A>, flatMapPolicy: FlatMapPolicy , onActionBlock: OnActionBlock <S, A>)","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-enter-in-state-side-effect-builder/","text":"dsl / com.freeletics.flowredux.dsl / OnEnterInStateSideEffectBuilder OnEnterInStateSideEffectBuilder \u00b6 (jvm) class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> A builder that generates a SideEffect that triggers every time the state machine enters a certain state. Constructors \u00b6 Name Summary (jvm) <init> A builder that generates a SideEffect that triggers every time the state machine enters a certain state. OnEnterInStateSideEffectBuilder(isInState: (S) -> Boolean , flatMapPolicy: FlatMapPolicy , block: InStateOnEnterBlock <S>)","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-enter-in-state-side-effect-builder/#onenterinstatesideeffectbuilder","text":"(jvm) class OnEnterInStateSideEffectBuilder<S : Any , A : Any > : InStateSideEffectBuilder <S, A> A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":"OnEnterInStateSideEffectBuilder"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-enter-in-state-side-effect-builder/#constructors","text":"Name Summary (jvm) <init> A builder that generates a SideEffect that triggers every time the state machine enters a certain state. OnEnterInStateSideEffectBuilder(isInState: (S) -> Boolean , flatMapPolicy: FlatMapPolicy , block: InStateOnEnterBlock <S>)","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-enter-in-state-side-effect-builder/-init-/","text":"dsl / com.freeletics.flowredux.dsl / OnEnterInStateSideEffectBuilder / <init> <init> \u00b6 (jvm) OnEnterInStateSideEffectBuilder(isInState: (S) -> Boolean , flatMapPolicy: FlatMapPolicy , block: InStateOnEnterBlock <S>) A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-on-enter-in-state-side-effect-builder/-init-/#init","text":"(jvm) OnEnterInStateSideEffectBuilder(isInState: (S) -> Boolean , flatMapPolicy: FlatMapPolicy , block: InStateOnEnterBlock <S>) A builder that generates a SideEffect that triggers every time the state machine enters a certain state.","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/","text":"dsl / com.freeletics.flowredux.dsl / SetState SetState \u00b6 (jvm) abstract class SetState<S> SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: fun doSomething ( setState : SetState < S >) { setState { SomeState } // Return the new state in the lambda. } You can also specify an parameter runIf that is checked before actually running setState block: fun doSomething ( setState : SetState < S >) { // Only executes { SomeState } if runIf={...} returns true setState ( runIf ={ state -> state is FooState }) { SomeState } } Constructors \u00b6 Name Summary (jvm) <init> SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: SetState(defaultRunIf: (S) -> Boolean ) Functions \u00b6 Name Summary (jvm) invoke abstract suspend operator fun invoke(runIf: (S) -> Boolean = defaultRunIf, reduce: (currentState: S) -> S): Unit","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/#setstate","text":"(jvm) abstract class SetState<S> SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: fun doSomething ( setState : SetState < S >) { setState { SomeState } // Return the new state in the lambda. } You can also specify an parameter runIf that is checked before actually running setState block: fun doSomething ( setState : SetState < S >) { // Only executes { SomeState } if runIf={...} returns true setState ( runIf ={ state -> state is FooState }) { SomeState } }","title":"SetState"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/#constructors","text":"Name Summary (jvm) <init> SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: SetState(defaultRunIf: (S) -> Boolean )","title":"Constructors"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/#functions","text":"Name Summary (jvm) invoke abstract suspend operator fun invoke(runIf: (S) -> Boolean = defaultRunIf, reduce: (currentState: S) -> S): Unit","title":"Functions"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/-init-/","text":"dsl / com.freeletics.flowredux.dsl / SetState / <init> <init> \u00b6 (jvm) SetState(defaultRunIf: (S) -> Boolean ) SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: fun doSomething ( setState : SetState < S >) { setState { SomeState } // Return the new state in the lambda. } You can also specify an parameter runIf that is checked before actually running setState block: fun doSomething ( setState : SetState < S >) { // Only executes { SomeState } if runIf={...} returns true setState ( runIf ={ state -> state is FooState }) { SomeState } }","title":" init "},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/-init-/#init","text":"(jvm) SetState(defaultRunIf: (S) -> Boolean ) SetState allows you to set the state of your state machine. It\u2019s just a convinient way along with DSL. Usage: fun doSomething ( setState : SetState < S >) { setState { SomeState } // Return the new state in the lambda. } You can also specify an parameter runIf that is checked before actually running setState block: fun doSomething ( setState : SetState < S >) { // Only executes { SomeState } if runIf={...} returns true setState ( runIf ={ state -> state is FooState }) { SomeState } }","title":"&lt;init&gt;"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/invoke/","text":"dsl / com.freeletics.flowredux.dsl / SetState / invoke invoke \u00b6 (jvm) abstract suspend operator fun invoke(runIf: (S) -> Boolean = defaultRunIf, reduce: (currentState: S) -> S): Unit","title":"Invoke"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/-set-state/invoke/#invoke","text":"(jvm) abstract suspend operator fun invoke(runIf: (S) -> Boolean = defaultRunIf, reduce: (currentState: S) -> S): Unit","title":"invoke"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/kotlinx.coroutines.flow.-flow/","text":"dsl / com.freeletics.flowredux.dsl / kotlinx.coroutines.flow.Flow Extensions for kotlinx.coroutines.flow.Flow \u00b6 Name Summary (jvm) reduxStore Provides a fluent DSL to specify a ReduxStore fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialStateSupplier: () -> S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialState: S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S>","title":"Index"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/kotlinx.coroutines.flow.-flow/#extensions-for-kotlinxcoroutinesflowflow","text":"Name Summary (jvm) reduxStore Provides a fluent DSL to specify a ReduxStore fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialStateSupplier: () -> S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialState: S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S>","title":"Extensions for kotlinx.coroutines.flow.Flow"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/kotlinx.coroutines.flow.-flow/redux-store/","text":"dsl / com.freeletics.flowredux.dsl / kotlinx.coroutines.flow.Flow / reduxStore reduxStore \u00b6 (jvm) fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialStateSupplier: () -> S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialState: S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> Provides a fluent DSL to specify a ReduxStore","title":"Redux store"},{"location":"Javadoc/dsl/com.freeletics.flowredux.dsl/kotlinx.coroutines.flow.-flow/redux-store/#reduxstore","text":"(jvm) fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialStateSupplier: () -> S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> fun <S : Any , A : Any > Flow<A>.reduxStore(logger: FlowReduxLogger? = null, initialState: S, block: FlowReduxStoreBuilder <S, A>.() -> Unit ): Flow<S> Provides a fluent DSL to specify a ReduxStore","title":"reduxStore"},{"location":"Javadoc/flowredux/","text":"flowredux Packages \u00b6 Name Summary (jvm) com.freeletics.flowredux Index \u00b6 All Types","title":"Index"},{"location":"Javadoc/flowredux/#packages","text":"Name Summary (jvm) com.freeletics.flowredux","title":"Packages"},{"location":"Javadoc/flowredux/#index","text":"All Types","title":"Index"},{"location":"Javadoc/flowredux/alltypes/","text":"All Types \u00b6 Name Summary (jvm) (extensions in package com.freeletics.flowredux) kotlinx.coroutines.flow.Flow \u00b6 |(jvm) com.freeletics.flowredux.FlowReduxLogger \u00b6 |(jvm) com.freeletics.flowredux.GetState \u00b6 The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. |(jvm) com.freeletics.flowredux.Reducer \u00b6 A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. |(jvm) com.freeletics.flowredux.ReducerException \u00b6 |(jvm) com.freeletics.flowredux.SideEffect \u00b6 It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics).","title":"Index"},{"location":"Javadoc/flowredux/alltypes/#all-types","text":"Name Summary (jvm) (extensions in package com.freeletics.flowredux)","title":"All Types"},{"location":"Javadoc/flowredux/alltypes/#kotlinxcoroutinesflowflow","text":"|(jvm)","title":"kotlinx.coroutines.flow.Flow"},{"location":"Javadoc/flowredux/alltypes/#comfreeleticsflowreduxflowreduxlogger","text":"|(jvm)","title":"com.freeletics.flowredux.FlowReduxLogger"},{"location":"Javadoc/flowredux/alltypes/#comfreeleticsflowreduxgetstate","text":"The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. |(jvm)","title":"com.freeletics.flowredux.GetState"},{"location":"Javadoc/flowredux/alltypes/#comfreeleticsflowreduxreducer","text":"A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. |(jvm)","title":"com.freeletics.flowredux.Reducer"},{"location":"Javadoc/flowredux/alltypes/#comfreeleticsflowreduxreducerexception","text":"|(jvm)","title":"com.freeletics.flowredux.ReducerException"},{"location":"Javadoc/flowredux/alltypes/#comfreeleticsflowreduxsideeffect","text":"It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics).","title":"com.freeletics.flowredux.SideEffect"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/","text":"flowredux / com.freeletics.flowredux Package com.freeletics.flowredux \u00b6 Types \u00b6 Name Summary (jvm) FlowReduxLogger interface FlowReduxLogger (jvm) GetState The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. typealias GetState<S> = () -> S (jvm) Reducer A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. typealias Reducer<S, A> = (S, A) -> S (jvm) SideEffect It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics). typealias SideEffect<S, A> = (actions: Flow<A>, getState: GetState <S>) -> Flow<A> Exceptions \u00b6 Name Summary (jvm) ReducerException class ReducerException : RuntimeException Extensions for External Classes \u00b6 Name Summary (jvm) kotlinx.coroutines.flow.Flow","title":"Index"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/#package-comfreeleticsflowredux","text":"","title":"Package com.freeletics.flowredux"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/#types","text":"Name Summary (jvm) FlowReduxLogger interface FlowReduxLogger (jvm) GetState The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state. typealias GetState<S> = () -> S (jvm) Reducer A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. typealias Reducer<S, A> = (S, A) -> S (jvm) SideEffect It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics). typealias SideEffect<S, A> = (actions: Flow<A>, getState: GetState <S>) -> Flow<A>","title":"Types"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/#exceptions","text":"Name Summary (jvm) ReducerException class ReducerException : RuntimeException","title":"Exceptions"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/#extensions-for-external-classes","text":"Name Summary (jvm) kotlinx.coroutines.flow.Flow","title":"Extensions for External Classes"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-get-state/","text":"flowredux / com.freeletics.flowredux / GetState GetState \u00b6 (jvm) typealias GetState<S> = () -> S The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state.","title":" get state"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-get-state/#getstate","text":"(jvm) typealias GetState<S> = () -> S The GetState is basically just a deferred way to get a state of a reduxStore at any given point in time. So you have to call this method to get the state.","title":"GetState"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer/","text":"flowredux / com.freeletics.flowredux / Reducer Reducer \u00b6 (jvm) typealias Reducer<S, A> = (S, A) -> S A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. If a reducer should not react on a Action, just return the old State. Parameters \u00b6 S - The type of the state A - The type of the Actions","title":" reducer"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer/#reducer","text":"(jvm) typealias Reducer<S, A> = (S, A) -> S A simple type alias for a reducer function. A Reducer takes a State and an Action as input and produces a state as output. If a reducer should not react on a Action, just return the old State.","title":"Reducer"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer/#parameters","text":"S - The type of the state A - The type of the Actions","title":"Parameters"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-side-effect/","text":"flowredux / com.freeletics.flowredux / SideEffect SideEffect \u00b6 (jvm) typealias SideEffect<S, A> = (actions: Flow<A>, getState: GetState <S>) -> Flow<A> It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics). Parameters \u00b6 actions - Input action. Every SideEffect should be responsible to handle a single Action (i.e using filter or ofType operator) state - GetState to get the latest state of the state machine","title":" side effect"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-side-effect/#sideeffect","text":"(jvm) typealias SideEffect<S, A> = (actions: Flow<A>, getState: GetState <S>) -> Flow<A> It is a function which takes a stream of actions and returns a stream of actions. Actions in, actions out (concept borrowed from redux-observable.js.or - so called epics).","title":"SideEffect"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-side-effect/#parameters","text":"actions - Input action. Every SideEffect should be responsible to handle a single Action (i.e using filter or ofType operator) state - GetState to get the latest state of the state machine","title":"Parameters"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-flow-redux-logger/","text":"flowredux / com.freeletics.flowredux / FlowReduxLogger FlowReduxLogger \u00b6 (jvm) interface FlowReduxLogger Functions \u00b6 Name Summary (jvm) log abstract fun log(message: String ): Unit","title":"Index"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-flow-redux-logger/#flowreduxlogger","text":"(jvm) interface FlowReduxLogger","title":"FlowReduxLogger"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-flow-redux-logger/#functions","text":"Name Summary (jvm) log abstract fun log(message: String ): Unit","title":"Functions"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-flow-redux-logger/log/","text":"flowredux / com.freeletics.flowredux / FlowReduxLogger / log log \u00b6 (jvm) abstract fun log(message: String ): Unit","title":"Log"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-flow-redux-logger/log/#log","text":"(jvm) abstract fun log(message: String ): Unit","title":"log"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer-exception/","text":"flowredux / com.freeletics.flowredux / ReducerException ReducerException \u00b6 (jvm) class ReducerException : RuntimeException Constructors \u00b6 Name Summary (jvm) <init> ReducerException(state: Any , action: Any , cause: Throwable )","title":"Index"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer-exception/#reducerexception","text":"(jvm) class ReducerException : RuntimeException","title":"ReducerException"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer-exception/#constructors","text":"Name Summary (jvm) <init> ReducerException(state: Any , action: Any , cause: Throwable )","title":"Constructors"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer-exception/-init-/","text":"flowredux / com.freeletics.flowredux / ReducerException / <init> <init> \u00b6 (jvm) ReducerException(state: Any , action: Any , cause: Throwable )","title":" init "},{"location":"Javadoc/flowredux/com.freeletics.flowredux/-reducer-exception/-init-/#init","text":"(jvm) ReducerException(state: Any , action: Any , cause: Throwable )","title":"&lt;init&gt;"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/kotlinx.coroutines.flow.-flow/","text":"flowredux / com.freeletics.flowredux / kotlinx.coroutines.flow.Flow Extensions for kotlinx.coroutines.flow.Flow \u00b6 Name Summary (jvm) reduxStore fun <A, S> Flow<A>.reduxStore(initialStateSupplier: () -> S, sideEffects: Iterable < SideEffect <S, A>>, logger: FlowReduxLogger ? = null, reducer: Reducer <S, A>): Flow<S>","title":"Index"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/kotlinx.coroutines.flow.-flow/#extensions-for-kotlinxcoroutinesflowflow","text":"Name Summary (jvm) reduxStore fun <A, S> Flow<A>.reduxStore(initialStateSupplier: () -> S, sideEffects: Iterable < SideEffect <S, A>>, logger: FlowReduxLogger ? = null, reducer: Reducer <S, A>): Flow<S>","title":"Extensions for kotlinx.coroutines.flow.Flow"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/kotlinx.coroutines.flow.-flow/redux-store/","text":"flowredux / com.freeletics.flowredux / kotlinx.coroutines.flow.Flow / reduxStore reduxStore \u00b6 (jvm) @ExperimentalCoroutinesApi @FlowPreview fun <A, S> Flow<A>.reduxStore(initialStateSupplier: () -> S, sideEffects: Iterable < SideEffect <S, A>>, logger: FlowReduxLogger ? = null, reducer: Reducer <S, A>): Flow<S>","title":"Redux store"},{"location":"Javadoc/flowredux/com.freeletics.flowredux/kotlinx.coroutines.flow.-flow/redux-store/#reduxstore","text":"(jvm) @ExperimentalCoroutinesApi @FlowPreview fun <A, S> Flow<A>.reduxStore(initialStateSupplier: () -> S, sideEffects: Iterable < SideEffect <S, A>>, logger: FlowReduxLogger ? = null, reducer: Reducer <S, A>): Flow<S>","title":"reduxStore"}]}